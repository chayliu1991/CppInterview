# 等待一个事件或其他条件

一个线程要等待另一个线程完成任务，确定完成任务的方法有几种。

- 第一种是持续检查  mutex，这种方法显然很浪费资源。
- 第二种是每隔一段时间进行一次检查。

```
bool flag;
std::mutex m;

void f()
{
	std::unique_lock<std::mutex> l(m);
	while (!flag)
	{
		l.unlock();
		std::this_thread::sleep_for(std::chrono::milliseconds(100)); //@ 休眠100ms
																	 //@ 休眠期间其他线程就有机会获取mutex并设置flag
		l.lock();
	}
}
```

但很难确定适当的休眠时间，过长（会直接影响程序行为，很少见）过短（相当于没有，一样浪费资源）都不好。

- 第三种方案是使用条件变量。

## 条件变量

标准库对条件变量提供了两种实现：std::condition_variable 和 std::condition_variable_any，前者仅限和 std::mutex 工作，而后者可以与任何满足最低标准的  mutex 工作（因此加上 _any 的后缀），更通用也意味着更大的开销，因此一般首选使用前者。

```
std::mutex m;
std::condition_variable cv;
std::string data;
bool ready = false;
bool processed = false;

void f()
{
	std::unique_lock<std::mutex> locker(m);
	cv.wait(locker, [] {return ready; });
	data += " after processing...";
	processed = true;
	locker.unlock();
	cv.notify_one();
}

int main()
{
	std::thread t(f);
	data = "data";

	//@ 使用{}包围是为了给 lock_guard 创建一个局部作用域
	{
		std::lock_guard<std::mutex> locker(m);
		data += " ready";
		ready = true;
		cv.notify_one();   //@ 唤醒 cv.wait
	}
	{
		std::unique_lock<std::mutex> locker(m);
		cv.wait(locker, [] {return processed; });
	}

	std::cout << data << "\n";
	t.join();
}
```

- wait() 中加入了 lambda 表达式用于判断相应的条件是否真正的达成，这是为了避免虚假唤醒导致的错误。
- wait() 传入的参数只能是 std::unique_lock 而不可以是 std::lock_guard：
  - lock_guard 没有 lock 和 unlock 接口，而 unique_lock 提供了相应的接口。
  - 在 wait() 函数之前，使用互斥锁保护了，如果 wait 的条件没有达成，wait() 函数会先调用互斥锁的 unlock() 函数，然后再将自己休眠，在被唤醒后，又会继续持有锁。

### 用条件变量实现线程安全的 queue















