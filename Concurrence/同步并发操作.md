# 等待一个事件或其他条件

一个线程要等待另一个线程完成任务，确定完成任务的方法有几种。

- 第一种是持续检查  mutex，这种方法显然很浪费资源。
- 第二种是每隔一段时间进行一次检查。

```
bool flag;
std::mutex m;

void f()
{
	std::unique_lock<std::mutex> l(m);
	while (!flag)
	{
		l.unlock();
		std::this_thread::sleep_for(std::chrono::milliseconds(100)); //@ 休眠100ms
																	 //@ 休眠期间其他线程就有机会获取mutex并设置flag
		l.lock();
	}
}
```

但很难确定适当的休眠时间，过长（会直接影响程序行为，很少见）过短（相当于没有，一样浪费资源）都不好。

- 第三种方案是使用条件变量。

## 条件变量

标准库对条件变量提供了两种实现：std::condition_variable 和 std::condition_variable_any，前者仅限和 std::mutex 工作，而后者可以与任何满足最低标准的  mutex 工作（因此加上 _any 的后缀），更通用也意味着更大的开销，因此一般首选使用前者。

```
std::mutex m;
std::condition_variable cv;
std::string data;
bool ready = false;
bool processed = false;

void f()
{
	std::unique_lock<std::mutex> locker(m);
	cv.wait(locker, [] {return ready; });
	data += " after processing...";
	processed = true;
	locker.unlock();
	cv.notify_one();
}

int main()
{
	std::thread t(f);
	data = "data";

	//@ 使用{}包围是为了给 lock_guard 创建一个局部作用域
	{
		std::lock_guard<std::mutex> locker(m);
		data += " ready";
		ready = true;
		cv.notify_one();   //@ 唤醒 cv.wait
	}
	{
		std::unique_lock<std::mutex> locker(m);
		cv.wait(locker, [] {return processed; });
	}

	std::cout << data << "\n";
	t.join();
}
```

- wait() 中加入了 lambda 表达式用于判断相应的条件是否真正的达成，这是为了避免虚假唤醒导致的错误。
- wait() 传入的参数只能是 std::unique_lock 而不可以是 std::lock_guard：
  - lock_guard 没有 lock 和 unlock 接口，而 unique_lock 提供了相应的接口。
  - 在 wait() 函数之前，使用互斥锁保护了，如果 wait 的条件没有达成，wait() 函数会先调用互斥锁的 unlock() 函数，然后再将自己休眠，在被唤醒后，又会继续持有锁。

## 用条件变量实现线程安全的 queue

和 std::stack 一样，std::queue  的接口设计存在固有竞争，因此需要将 front 和 pop 合并成一个函数（就像合并 std::stack 的 top 和 pop）。这里提供了 pop 的两个变种 ：

- try_pop 总会直接返回（即使没有可弹出的值）。
- wait_and_pop 等待有值可检索才返回。

```
#include <mutex>
#include <condition_variable>
#include <queue>

template<typename T>
class threadsafe_queue
{
	mutable std::mutex m;
	std::queue<T> q;
	std::condition_variable cv;
public:
	threadsafe_queue() {}
	threadsafe_queue(const threadsafe_queue& rhs)
	{
		std::lock_guard<std::mutex>l(m);
		q = rhs.q;
	}

	void push(T x)
	{
		std::lock_guard<std::mutex>l(m);
		q.push(std::move(x));
		cv.notify_one();
	}

	void wait_and_pop(T &x)
	{
		std::unique_lock<std::mutex> l(m);
		cv.wait(l, [this] {return !q.empty(); });
		x = std::move(q.front());
		q.pop();
	}

	std::shared_ptr<T> wait_and_pop()
	{
		std::unique_lock<std::mutex> l(m);
		cv.wait(l, [this] {return !q.empty(); });
		std::shared_ptr<T> res(std::make_shared<T>(std::move(q.front())));
		q.pop();
		return res;
	}

	bool try_pop(T& x)
	{
		std::lock_guard<std::mutex>l(m);
		if (q.empty())
			return false;
		x = std::move(q.front());
		return true;
	}

	std::shared_ptr<T> try_pop()
	{
		std::lock_guard<std::mutex>l(m);
		if (q.empty())
			return false;
		std::shared_ptr<T> res(std::make_shared<T>(std::move(q.front())));
		return true;
	}

	bool empty() const
	{
		std::lock_guard<std::mutex> l(m);
		return q.empty();
	}
};
```

# 使用期值等待一次性事件

`<future>` 头文件中包含了以下几个类和函数：

- Providers 类：std::promise, std::package_task
- Futures 类：std::future , shared_future
- Providers 函数：std::async()
- 其他类型：std::future_error, std::future_errc, std::future_status, std::launch

标准库提供了只能关联一个事件的唯一期值 future 和能关联多个事件的共享期值 std::shared_future。

最简单的一次性事件就是运行在后台的计算结果，而 std::thread 不能获取返回值：

```
int f()
{
	return 1;
}

int main()
{
	std::thread t(f); //@ 如何读取f的返回值？
	t.join();
	
	return 0;
}
```

## promise

promise<T> 是一个模板类：

- T 为 promise 对象保存的值的类型，R 可以是 void 类型，此时 promise::set_value 不接受任何参数，仅用于通知关联的 future::get 解除阻塞。
- promise 保存的值可被与之关联的 future 读取，读取操作可以发生在其它线程。
- promise 允许 move 语义(右值构造，右值赋值)，但不允许拷贝(拷贝构造、赋值)，[future](https://en.cppreference.com/w/cpp/thread/future)  亦然。
- promise 和 future 合作共同实现了多线程间通信。

### 设置 std::promise 的值

promise::set_value 可以设置 promise 中保存的值，该值最终会被与之关联的 future::get 读取到。

promise::set_value 只能被调用一次，多次调用会抛出 future_error 异常。事实上 promise::set_value 函数会改变 promise 的状态为 ready，再次调用时发现状态已要是 ready 了，则抛出异常：

```
#include <iostream> 
#include <thread>  
#include <string>   
#include <future>   
#include <chrono>  
using namespace std::chrono;

void read(std::future<std::string> *future) {
	//@ future会一直阻塞，一直到有值到来
	std::cout << __func__<<" output: "<<future->get() << std::endl;
}

int main() 
{
	//@ promise 相当于生产者
	std::promise<std::string> promise;
	//@ future 相当于消费者, 右值构造
	std::future<std::string> future = promise.get_future();
	//@ 另一线程中通过future来读取promise的值
	std::thread t(read, &future);
	//@ 让read等一会儿:)
	std::this_thread::sleep_for(seconds(1));

	promise.set_value("hello future");
	t.join();

	return 0;
}
```

- 在 promise 构造时，promise 对象会与共享状态关联起来，这个共享状态可以存储一个 T 类型的值或者一个由 std::exception 派生出来的异常值。
- 通过 promise::get_future 调用获得的 future  与 promise 共享相同的共享状态。

### 当 std::promise 不设置值

如果 promise 直到销毁时，都未设置过任何值，则 promise 会在析构时自动设置为 future_error，这会造成 future::get 抛出 future_error 异常。

```
void read(std::future<int> future)
{
	try {
		future.get();
	}
	catch (std::future_error &e) {
		std::cerr << "error code:" << e.code() << "\n" << "error info:" << e.what() << std::endl;
	}
}

int main() {
	std::thread thread;
	{
		std::promise<int> promise;
		thread = std::thread(read, promise.get_future());
	}
	thread.join();

	return 0;
}
```

### 将异常存储于期值中

通过 promise::set_exception 函数可以设置自定义异常，该异常最终会被传递到 future，并在其 future::get 函数中被抛出。

```
int f(int x)
{
	if (x < 0)
	{
		throw std::out_of_range("x < 0");
	}
	return 1;
}

int main()
{
	std::promise<int> ps;
	auto ft = ps.get_future();
	std::thread t([&ps]
	{
		try
		{
			ps.set_value(f(-1)); //@ 此时还没有存储异常
		}
		catch (...)
		{
			ps.set_exception(std::current_exception()); //@ 存储异常
		}
	});
	t.join();
	ft.get();

	return 0;
}
```

promise 支持自定义异常：

```
void catch_error(std::future<void> &future) {
	try {
		future.get();
	}
	catch (std::logic_error &e) {
		std::cerr << "logic_error: " << e.what() << std::endl;
	}
}

int main() 
{
	std::promise<void> promise;
	std::future<void> future = promise.get_future();

	std::thread thr(catch_error, std::ref(future));
	//@ 自定义异常需要使用make_exception_ptr转换一下
	promise.set_exception(
		std::make_exception_ptr(std::logic_error("caught")));

	thr.join();
	return 0;
}
```

### std::promise 所在线程退出

promise 支持定制线程退出时的行为： 

- promise::set_value_at_thread_exit
  设置共享状态的值，但是不将共享状态的标志设置为 ready，当线程退出时该 promise 对象会自动设置为 ready。如果某个 future  对象与该 promise 对象的共享状态相关联，并且该 future 正在调用 future::get，则调用 future::get 的线程会被阻塞，当线程退出时，调用 future::get 的线程解除阻塞，同时返回 promise::set_value_at_thread_exit 所设置的值。注意，该函数已经设置了 promise 共享状态的值
- promise::set_exception_at_thread_exit
  线程退出时，future 则抛出该函数指定的异常。

## packaged_task















