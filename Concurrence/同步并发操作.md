# 等待一个事件或其他条件

一个线程要等待另一个线程完成任务，确定完成任务的方法有几种。

- 第一种是持续检查  mutex，这种方法显然很浪费资源。
- 第二种是每隔一段时间进行一次检查。

```
bool flag;
std::mutex m;

void f()
{
	std::unique_lock<std::mutex> l(m);
	while (!flag)
	{
		l.unlock();
		std::this_thread::sleep_for(std::chrono::milliseconds(100)); //@ 休眠100ms
																	 //@ 休眠期间其他线程就有机会获取mutex并设置flag
		l.lock();
	}
}
```

但很难确定适当的休眠时间，过长（会直接影响程序行为，很少见）过短（相当于没有，一样浪费资源）都不好。

- 第三种方案是使用条件变量。

## 条件变量

标准库对条件变量提供了两种实现：std::condition_variable 和 std::condition_variable_any，前者仅限和 std::mutex 工作，而后者可以与任何满足最低标准的  mutex 工作（因此加上 _any 的后缀），更通用也意味着更大的开销，因此一般首选使用前者。

```
std::mutex m;
std::condition_variable cv;
std::string data;
bool ready = false;
bool processed = false;

void f()
{
	std::unique_lock<std::mutex> locker(m);
	cv.wait(locker, [] {return ready; });
	data += " after processing...";
	processed = true;
	locker.unlock();
	cv.notify_one();
}

int main()
{
	std::thread t(f);
	data = "data";

	//@ 使用{}包围是为了给 lock_guard 创建一个局部作用域
	{
		std::lock_guard<std::mutex> locker(m);
		data += " ready";
		ready = true;
		cv.notify_one();   //@ 唤醒 cv.wait
	}
	{
		std::unique_lock<std::mutex> locker(m);
		cv.wait(locker, [] {return processed; });
	}

	std::cout << data << "\n";
	t.join();
}
```

- wait() 中加入了 lambda 表达式用于判断相应的条件是否真正的达成，这是为了避免虚假唤醒导致的错误。
- wait() 传入的参数只能是 std::unique_lock 而不可以是 std::lock_guard：
  - lock_guard 没有 lock 和 unlock 接口，而 unique_lock 提供了相应的接口。
  - 在 wait() 函数之前，使用互斥锁保护了，如果 wait 的条件没有达成，wait() 函数会先调用互斥锁的 unlock() 函数，然后再将自己休眠，在被唤醒后，又会继续持有锁。

## 用条件变量实现线程安全的 queue

和 std::stack 一样，std::queue  的接口设计存在固有竞争，因此需要将 front 和 pop 合并成一个函数（就像合并 std::stack 的 top 和 pop）。这里提供了 pop 的两个变种 ：

- try_pop 总会直接返回（即使没有可弹出的值）。
- wait_and_pop 等待有值可检索才返回。

```
#include <mutex>
#include <condition_variable>
#include <queue>

template<typename T>
class threadsafe_queue
{
	mutable std::mutex m;
	std::queue<T> q;
	std::condition_variable cv;
public:
	threadsafe_queue() {}
	threadsafe_queue(const threadsafe_queue& rhs)
	{
		std::lock_guard<std::mutex>l(m);
		q = rhs.q;
	}

	void push(T x)
	{
		std::lock_guard<std::mutex>l(m);
		q.push(std::move(x));
		cv.notify_one();
	}

	void wait_and_pop(T &x)
	{
		std::unique_lock<std::mutex> l(m);
		cv.wait(l, [this] {return !q.empty(); });
		x = std::move(q.front());
		q.pop();
	}

	std::shared_ptr<T> wait_and_pop()
	{
		std::unique_lock<std::mutex> l(m);
		cv.wait(l, [this] {return !q.empty(); });
		std::shared_ptr<T> res(std::make_shared<T>(std::move(q.front())));
		q.pop();
		return res;
	}

	bool try_pop(T& x)
	{
		std::lock_guard<std::mutex>l(m);
		if (q.empty())
			return false;
		x = std::move(q.front());
		return true;
	}

	std::shared_ptr<T> try_pop()
	{
		std::lock_guard<std::mutex>l(m);
		if (q.empty())
			return false;
		std::shared_ptr<T> res(std::make_shared<T>(std::move(q.front())));
		return true;
	}

	bool empty() const
	{
		std::lock_guard<std::mutex> l(m);
		return q.empty();
	}
};
```

# 使用期值等待一次性事件

`<future>` 头文件中包含了以下几个类和函数：

- Providers 类：std::promise, std::package_task
- Futures 类：std::future , shared_future
- Providers 函数：std::async()
- 其他类型：std::future_error, std::future_errc, std::future_status, std::launch

标准库提供了只能关联一个事件的唯一期值 future 和能关联多个事件的共享期值 std::shared_future。

最简单的一次性事件就是运行在后台的计算结果，而 std::thread 不能获取返回值：

```
int f()
{
	return 1;
}

int main()
{
	std::thread t(f); //@ 如何读取f的返回值？
	t.join();
	
	return 0;
}
```

## future

- future::get 会一直阻塞，直到获取到结果或异步任务抛出异常。
- future::share 允许 move，但是不允许拷贝。future::share  通过引用计数的方式实现了多实例共享同一状态，但有计数就伴随着同步开销(无锁的原子操作也是有开销的)，性能会稍有下降。因此  C++11 要求程序员显式调用该函数，以表明用户对由此带来的开销负责。
- future::wait 一直等待直到数据就绪。数据就绪时，通过 get 函数，无等待即可获得数据。
- future::wait_for 和 future::wait_until 主要是用来进行超时等待的。future::wait_for 等待指定时长，future::wait_until 则等待到指定的时间点。返回值有 3 种状态：
  - ready，数据已就绪，可以通过get获取了。
  - timeout，超时，数据还未准备好。
  - deferred，这个和 std::async 相关，表明无需 wait，异步函数将在 get 时执行。

- future::valid 判断当前实例是否有效。future 主要是用来获取异步任务结果的，作为消费方出现，单独构建出来的实例没意义，因此为 false。当与其它生产方(Provider)通过共享状态关联后，才会变得有效，future 才会发挥实际的作用。C++11 中有下面几种 Provider，从这些 Provider 可获得有效的 future 实例：
  - std::async
  - promise::get_future
  - packaged_task::get_future

- 共享状态
  - 共享状态其本质就是单生产者-单消费者的多线程并发模型。
  - 无论是 promise 还是 packaged_task 都是通过共享状态，实现与 future 通信的。

### shared_future

future 调用 future::get 后就无法再次 future::get，也就是说只能获取一次数据，此外还会导致所在线程与其他线程数据不同步。std::shared_future 就可以解决此问题。

```
std::promise<int> ps;
std::future<int> ft(ps.get_future());
assert(ft.valid());
std::shared_future<int> sf(std::move(ft));
assert(!ft.valid());
assert(sf.valid());
```

也可以直接构造：

```
std::promise<int> ps;
//@ std::future隐式转换为std::shared_future
std::shared_future<int> sf(ps.get_future());
```

用 future::share 可以直接生成 future::share，这样就可以直接用 auto 简化声明 std::shared_future。

```
std::promise<int> ps;
auto sf = ps.get_future().share();
```

每一个 std::shared_future 对象上返回的结果不同步，为了避免多线程访问同一 std::shared_future  对象时的数据竞争就必须加锁保护。更好的方法是给每个线程拷贝一个 std::shared_future 对象，这样就可以安全访问而无需加锁。

## async

使用 std::async 可以启动一个异步任务，它返回一个持有计算结果的 future，通过 future::get 即可阻塞线程，直到期值的状态为 ready 并返回该结果。

```
int f()
{
	return 1;
}

int main()
{
	std::future<int> ft = std::async(f);
	std::cout << ft.get() << "\n"; //@ 1
}
```

std::async 和 std::thread 一样支持额外的函数参数：

```
//@ 函数
int f(int);
auto ft = std::async(f, 42);

//@ 成员函数
struct A {
	int x{ 0 };
	int f(int)
	{
		x++;
		return 1;
	}
};

A a;
auto ft1 = std::async(&A::f, &a, 42); //@ 调用 p->f(42),p是指向a的对象
auto ft2 = std::async(&A::f, a, 42); //@ 调用 tmpa.f(42),tmpa是a的副本

									 //@ 函数对象
struct A {
	int operator()(int);
};

A a;
auto ft1 = std::async(A(), 42); //@ 调用tmpa(42)，tmpa由A的移动构造函数获得
auto ft2 = std::async(std::ref(a), 42); //@ 调用a(42)
```

std::async 还可以设置第一个参数为线程的创建策略：

- std::launch::async：函数必须异步执行，即运行在不同的线程上。
- std::launch::deferred：当其它线程调用 future::get 时，将调用非异步形式。
- std::launch::async | std::launch::deferred ：不指定时的默认启动策略是对两者进行或运算的结果。

```
int f();
auto ft1 = std::async(std::launch::async, f);
auto ft2 = std::async(std::launch::deferred, f);
auto ft3 = std::async(std::launch::async | std::launch::deferred, f);
```

## promise

promise<T> 是一个模板类：

- T 为 promise 对象保存的值的类型，R 可以是 void 类型，此时 promise::set_value 不接受任何参数，仅用于通知关联的 future::get 解除阻塞。
- promise 保存的值可被与之关联的 future 读取，读取操作可以发生在其它线程。
- promise 允许 move 语义(右值构造，右值赋值)，但不允许拷贝(拷贝构造、赋值)，[future](https://en.cppreference.com/w/cpp/thread/future)  亦然。
- promise 和 future 合作共同实现了多线程间通信。

### 设置 std::promise 的值

promise::set_value 可以设置 promise 中保存的值，该值最终会被与之关联的 future::get 读取到。

promise::set_value 只能被调用一次，多次调用会抛出 future_error 异常。事实上 promise::set_value 函数会改变 promise 的状态为 ready，再次调用时发现状态已要是 ready 了，则抛出异常：

```
#include <iostream> 
#include <thread>  
#include <string>   
#include <future>   
#include <chrono>  
using namespace std::chrono;

void read(std::future<std::string> *future) {
	//@ future会一直阻塞，一直到有值到来
	std::cout << __func__<<" output: "<<future->get() << std::endl;
}

int main() 
{
	//@ promise 相当于生产者
	std::promise<std::string> promise;
	//@ future 相当于消费者, 右值构造
	std::future<std::string> future = promise.get_future();
	//@ 另一线程中通过future来读取promise的值
	std::thread t(read, &future);
	//@ 让read等一会儿:)
	std::this_thread::sleep_for(seconds(1));

	promise.set_value("hello future");
	t.join();

	return 0;
}
```

- 在 promise 构造时，promise 对象会与共享状态关联起来，这个共享状态可以存储一个 T 类型的值或者一个由 std::exception 派生出来的异常值。
- 通过 promise::get_future 调用获得的 future  与 promise 共享相同的共享状态。

### 当 std::promise 不设置值

如果 promise 直到销毁时，都未设置过任何值，则 promise 会在析构时自动设置为 future_error，这会造成 future::get 抛出 future_error 异常。

```
void read(std::future<int> future)
{
	try {
		future.get();
	}
	catch (std::future_error &e) {
		std::cerr << "error code:" << e.code() << "\n" << "error info:" << e.what() << std::endl;
	}
}

int main() {
	std::thread thread;
	{
		std::promise<int> promise;
		thread = std::thread(read, promise.get_future());
	}
	thread.join();

	return 0;
}
```

### 将异常存储于期值中

通过 promise::set_exception 函数可以设置自定义异常，该异常最终会被传递到 future，并在其 future::get 函数中被抛出。

```
int f(int x)
{
	if (x < 0)
	{
		throw std::out_of_range("x < 0");
	}
	return 1;
}

int main()
{
	std::promise<int> ps;
	auto ft = ps.get_future();
	std::thread t([&ps]
	{
		try
		{
			ps.set_value(f(-1)); //@ 此时还没有存储异常
		}
		catch (...)
		{
			ps.set_exception(std::current_exception()); //@ 存储异常
		}
	});
	t.join();
	ft.get();

	return 0;
}
```

promise 支持自定义异常：

```
void catch_error(std::future<void> &future) {
	try {
		future.get();
	}
	catch (std::logic_error &e) {
		std::cerr << "logic_error: " << e.what() << std::endl;
	}
}

int main() 
{
	std::promise<void> promise;
	std::future<void> future = promise.get_future();

	std::thread thr(catch_error, std::ref(future));
	//@ 自定义异常需要使用make_exception_ptr转换一下
	promise.set_exception(
		std::make_exception_ptr(std::logic_error("caught")));

	thr.join();
	return 0;
}
```

### std::promise 所在线程退出

promise 支持定制线程退出时的行为： 

- promise::set_value_at_thread_exit
  设置共享状态的值，但是不将共享状态的标志设置为 ready，当线程退出时该 promise 对象会自动设置为 ready。如果某个 future  对象与该 promise 对象的共享状态相关联，并且该 future 正在调用 future::get，则调用 future::get 的线程会被阻塞，当线程退出时，调用 future::get 的线程解除阻塞，同时返回 promise::set_value_at_thread_exit 所设置的值。注意，该函数已经设置了 promise 共享状态的值
- promise::set_exception_at_thread_exit
  线程退出时，future 则抛出该函数指定的异常。

## packaged_task

packaged_task 对一个函数或可调用对象绑定一个期望，当 packaged_task 的对象被调用时，它就会调用相关函数或者可调用对象，将期望状态设置为就绪，返回值也会被存储为相关数据。

- packaged_task 的模板参数是一个函数签名，当实例化一个 packaged_task 对象时，需要传入一个函数或者可调用对象，这个函数或可调用对象需要指定能接收指定的参数和返回可转换为指定返回类型的值。
- packaged_task 支持 move，但不支持拷贝。

```
int sum(int a, int b) {
	return a + b;
}

int main() {
	std::packaged_task<int(int, int)> task(sum);
	std::future<int> future = task.get_future();
	std::thread t(std::move(task), 1, 2);
	//@ 等待异步计算结果
	std::cout << "1 + 2 = " << future.get() << std::endl;

	t.join();
	return 0;
}
```

### packaged_task::valid

packaged_task 除了可以通过可调用对象构造外，还支持缺省构造。但此时构造的对象不能直接使用，需通过右值赋值操作设置了可调用对象或函数后才可使用。判断一个 packaged_task 是否可使用，可通过其成员函数 packaged_task::valid 来判断。

```
int main() {
	std::packaged_task<void()> task; //@ 缺省构造、默认构造
	std::cout << std::boolalpha << task.valid() << std::endl; //@ false

	std::packaged_task<void()> task2(std::move(task)); //@ 移动构造
	std::cout << std::boolalpha << task.valid() << std::endl; //@ false

	task = std::packaged_task<void()>([]() {});  //@ 移动赋值, 可调用对象
	std::cout << std::boolalpha << task.valid() << std::endl; //@ true

	return 0;
}
```

### packaged_task::operator()

packaged_task::operator() 的返回值是 void，即无返回值。因为 packaged_task 的设计主要是用来进行异步调用，因此 packaged_task::operator() 的计算结果是通过 future::get 来获取的。该函数会忠实地将计算结果反馈给 future，即使抛出异常(此时 future::get 也会抛出同样的异常)。

```
int main() {
	std::packaged_task<void()> convert([]() {
		throw std::logic_error("will catch in future");
	});
	std::future<void> future = convert.get_future();

	convert(); //@ 异常不会在此处抛出

	try {
		future.get();
	}
	catch (std::logic_error &e) {
		std::cerr << typeid(e).name() << ": " << e.what() << std::endl;
	}

	return 0;
}
```

### std::packaged_task 所在线程退出时

packaged_task::make_ready_at_thread_exit 函数接收的参数与 packaged_task::operator() 一样，行为也一样。只有一点差别，那就是不会将计算结果立刻反馈给 future，而是在其执行时所在的线程结束后，future::get 才会取得结果。

### std::packaged_task::reset

与 promise 不一样，promise 仅可以执行一次 promise::set_value 或 promise::set_exception 函数，但 packaged_task 可以执行多次，其奥秘就是 packaged_task::reset 函数。packaged_task::reset  重新构造了 promise，packaged_task::reset  操作并不会影响之前调用的 packaged_task::make_ready_at_thread_exit 结果，也即之前的定制的行为在线程退出时仍会发生。

### 多线程GUI更新示例

很多GUI架构要求用指定线程更新GUI，如果另一个线程要更新GUI，就需要发送信消息给指定线程。使用 packaged_task 即可实现此功能。

```
//@ 更新GUI的线程
void gui_thread()
{
	while (!gui_shutdown_message_received()) //@ 未收到终止消息则一直轮询
	{
		process_gui_message(); //@ 处理收到的消息
		std::packaged_task<void()> pt;
		{
			std::lock_guard<std::mutex> l(m);
			if (d.empty())
				continue; //@ 任务队列为空时，继续循环
			pt = std::move(d.front());
			d.pop_front();
		}
		pt(); //@ 执行任务，当任务执行完成时，其状态会被设置为就绪状态
	}
}

std::thread t(gui_thread);

//@ 将一个任务传入队列
template<typename F>
std::future<void> postTask(F f)
{
	std::packaged_task<void()> pt(f); //@ 提供一个打包好的任务
	std::future<void> res = pt.get_future(); //@ 获取期望
	std::lock_guard<std::mutex> l(m);
	d.push_back(std::move(pt));
	return res;
}
```



