# 设计并发数据结构的建议

设计并发数据结构要考虑两点，一是确保访问 thread-safe，二是允许真正的并发访问。thread-safe 基本要求如下

- 数据结构的不变量被一个线程破坏时，确保不被其他线程看到此状态。
- 提供操作完整的函数来避免数据结构接口中固有的 race condition。
- 注意数据结构出现异常时的行为，以确保不变量不被破坏。
- 限制锁的范围，避免可能的嵌套锁，最小化死锁的概率。

关于真正的并发访问没有太多建议，但作为数据结构的设计者需要考虑以下问题

- 部分操作是否可以在锁的范围外执行。
- 数据结构的不同部分是否被不同的 mutex 保护。
- 是否所有操作需要同级别的保护。
- 在不影响操作语义的前提下，能否对数据结构做一个简单的修改提高并发访问的概率。

这些问题可以总结为一点，即如何最小化线程对被 mutex 保护的数据的轮流访问，以及最大化真实的并发量。

# 使用锁实现 thread-safe stack

```
struct emptyStack : std::exception
{
	const char* what() const noexcept
	{
		return "empty stack!";
	}
};

template<typename T>
class A {
	std::stack<T> s;
	mutable std::mutex m;
public:
	A() : s(std::stack<T>()) {}

	A(const A& rhs)
	{
		std::lock_guard<std::mutex> l(rhs.m);
		s = rhs.s;
	}

	A& operator=(const A&) = delete;

	void push(T n)
	{
		std::lock_guard<std::mutex> l(m);
		s.push(std::move(n));
	}

	std::shared_ptr<T> pop() //@ 返回一个指向栈顶元素的指针
	{
		std::lock_guard<std::mutex> l(m);
		if (s.empty()) throw emptyStack();
		const std::shared_ptr<T> res(std::make_shared<T>(std::move(s.top())));
		s.pop();
		return res;
	}

	void pop(T& n) //@ 传引用获取结果
	{
		std::lock_guard<std::mutex> l(m);
		if (s.empty()) throw emptyStack();
		n = std::move(s.top());
		s.pop();
	}

	bool empty() const
	{
		std::lock_guard<std::mutex> l(m);
		return s.empty();
	}
};
```

# 使用锁和条件变量实现 thread-safe queue

```
template<typename T>
class A {
	mutable std::mutex m;
	std::queue<T> q;
	std::condition_variable cv;
public:
	A() {}
	A(const A& rhs)
	{
		std::lock_guard<std::mutex> l(rhs.m);
		q = rhs.q;
	}

	void push(T x)
	{
		std::lock_guard<std::mutex> l(m);
		q.push(std::move(x));
		cv.notify_one();
	}

	void wait_and_pop(T& x)
	{
		std::unique_lock<std::mutex> l(m);
		//@ 在queue中有元素时才返回，而不必持续调用empty
		cv.wait(l, [this] { return !q.empty(); });
		x = std::move(q.front());
		q.pop();
	}

	std::shared_ptr<T> wait_and_pop()
	{
		std::unique_lock<std::mutex> l(m);
		cv.wait(l, [this] { return !q.empty(); });
		std::shared_ptr<T> res(std::make_shared<T>(std::move(q.front())));
		q.pop();
		return res;
	}

	bool try_pop(T& x)
	{
		std::lock_guard<std::mutex> l(m);
		if (q.empty()) return false;
		x = std::move(q.front());
		q.pop();
		return true;
	}

	std::shared_ptr<T> try_pop()
	{
		std::lock_guard<std::mutex> l(m);
		if (q.empty()) return std::shared_ptr<T>();
		std::shared_ptr<T> res(std::make_shared<T>(std::move(q.front())));
		q.pop();
		return res;
	}

	bool empty() const
	{
		std::lock_guard<std::mutex> l(m);
		//@ 其他线程可能有此对象（拷贝构造）所以要上锁
		return q.empty();
	}
};
```

这引入了一个异常安全问题，多个线程处于等待时，notify_one 只会唤醒一个线程，如果这个线程在 wait_and_pop中（比如构造 std::shared_ptr 对象时就可能）抛出异常，其余线程将永远不会唤醒。

- 将 notify_one  改为 notify_all，这样就会唤醒所有线程，代价是大部分线程发现 queue 仍为 empty 时，又会继续休眠。
- 抛出异常时让 wait_and_pop 调用 notify_one，从而唤醒另一个线程。
- 将 std::shared_ptr 的初始化移到 push 中，并且内部的 std::queue 不直接存储值，而是存储管理值的 std::shared_ptr 。

```
#include <memory>
#include <mutex>
#include <condition_variable>
#include <queue>

template<typename T>
class A {
    mutable std::mutex m;
    std::queue<std::shared_ptr<T>> q; //@ 之前为std::queue<T> q
    std::condition_variable cv;
public:
    A() {}
    A(const A& rhs)
    {
        std::lock_guard<std::mutex> l(rhs.m);
        q = rhs.q;
    }

    void push(T x)
    {
        std::shared_ptr<T> data(std::make_shared<T>(std::move(x)));
        //@ 上面的构造在锁外完成，之前只能在pop中且持有锁时完成
        //@ 内存分配操作开销很大，这种做法减少了mutex的持有时间，提升了性能
        std::lock_guard<std::mutex> l(m);
        q.push(data); //@ 之前为q.push(std::move(x))
        cv.notify_one();
    }

    void wait_and_pop(T& x)
    {
        std::unique_lock<std::mutex> l(m);
        cv.wait(l, [this] { return !q.empty(); });
        x = std::move(*q.front()); //@ 之前为std::move(q.front())
        q.pop();
    }

    std::shared_ptr<T> wait_and_pop()
    {
        std::unique_lock<std::mutex> l(m);
        cv.wait(l, [this] { return !q.empty(); });
        std::shared_ptr<T> res = q.front();
        //@ 之前为std::make_shared<T>(std::move(q.front()))
        //@ 现在构造转移到了push中
        q.pop();
        return res;
    }

    bool try_pop(T& x)
    {
        std::lock_guard<std::mutex> l(m);
        if (q.empty()) return false;
        x = std::move(*q.front()); //@ 之前为std::move(q.front())
        q.pop();
        return true;
    }

    std::shared_ptr<T> try_pop()
    {
        std::lock_guard<std::mutex> l(m);
        if (q.empty()) return std::shared_ptr<T>();
        std::shared_ptr<T> res = q.front();
        //@ 之前为std::make_shared<T>(std::move(q.front()))
        q.pop();
        return res;
    }

    bool empty() const
    {
        std::lock_guard<std::mutex> l(m);
        return q.empty();
    }
};
```

# 使用细粒度锁和条件变量实现 thread-safe queue











