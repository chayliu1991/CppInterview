# 让接口容易被正确使用，不易被误用

## 建立新类型，束缚对象值防止误用

Date 对象的构造函数需要传入月、日、年。但客户在调用时常常传错顺序，这时可以将参数封装为对象来提供类型检查：

```
class Date{
public:
    Date(const Month& m, const Day& d, const Year& y);
};
 
Date d(Day(30), Month(3), Year(1995));    // 编译错：类型不兼容！
Date d(Month(3), Day(30), Year(1995));    // OK
```

即使这样，用户的 Month 构造函数仍然会传入一个不合理的参数（例如 32），或者搞不清楚下标从0还是1开始。 

解决方案是预定义所有可用的 Month。办法之一就是利用 enum 表现月份，但是 enum 不具有类型安全，因为 enum 本质是一个 int 类型。比较安全的一个办法是预先定义所有的月份。

```
class Month {
public:
  static Month Jan() { return Month(1); }  
  static Month Feb() { return Month(2); }   
  ...                                       
  static Month Dec() { return Month(12); } 
  ...                                   
private:
  explicit Month(int m);                                               
  ...                                      
};
Date d(Month::Mar(), Day(30), Year(1995));
```

## 与内建类型保持一致

除非你有很棒的理由，否则就让你的类型的行为与内建类型保持一致。例如，如果 a 和 b 是 int，给 a*b 赋值是非法的。

例如，使 `operator*` 的返回类型具有 const 是如何能够防止客户对用户自定义类型犯下这样的错误：

```
if (a * b = c) ... //@ 这里其实打算做比较，而不是赋值
```

## 限制类型上的操作、消除客户资源管理的责任防止误用

好的接口不会要求用户去记住某些事情。比如 `Investment* createInvestment()` 为了避免资源泄露，CreateInvestment 返回的指针必须被删除，这样客户就有了两个犯错误的机会：没有删除指针，或者删除了不止一次。

解决方案便是返回一个智能指针而不是原始资源，而我们返回智能指针时就能指定 deleter 来自定义销毁动作：

```
shared_ptr<Investment> createInvestment(){
    // 销毁一项投资时，需要做一些取消投资的业务，而不是简单地`delete`
    return shared_ptr<Investment>(new Stock, getRidOfInvestment);
}
```

















