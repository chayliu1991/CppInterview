# 让接口容易被正确使用，不易被误用

## 建立新类型，束缚对象值防止误用

Date 对象的构造函数需要传入月、日、年。但客户在调用时常常传错顺序，这时可以将参数封装为对象来提供类型检查：

```
class Date{
public:
    Date(const Month& m, const Day& d, const Year& y);
};
 
Date d(Day(30), Month(3), Year(1995));    // 编译错：类型不兼容！
Date d(Month(3), Day(30), Year(1995));    // OK
```

即使这样，用户的 Month 构造函数仍然会传入一个不合理的参数（例如 32），或者搞不清楚下标从0还是1开始。 

解决方案是预定义所有可用的 Month。办法之一就是利用 enum 表现月份，但是 enum 不具有类型安全，因为 enum 本质是一个 int 类型。比较安全的一个办法是预先定义所有的月份。

```
class Month {
public:
  static Month Jan() { return Month(1); }  
  static Month Feb() { return Month(2); }   
  ...                                       
  static Month Dec() { return Month(12); } 
  ...                                   
private:
  explicit Month(int m);                                               
  ...                                      
};
Date d(Month::Mar(), Day(30), Year(1995));
```

## 与内建类型保持一致

除非你有很棒的理由，否则就让你的类型的行为与内建类型保持一致。例如，如果 a 和 b 是 int，给 a*b 赋值是非法的。

例如，使 `operator*` 的返回类型具有 const 是如何能够防止客户对用户自定义类型犯下这样的错误：

```
if (a * b = c) ... //@ 这里其实打算做比较，而不是赋值
```

## 限制类型上的操作、消除客户资源管理的责任防止误用

好的接口不会要求用户去记住某些事情。比如 `Investment* createInvestment()` 为了避免资源泄露，CreateInvestment 返回的指针必须被删除，这样客户就有了两个犯错误的机会：没有删除指针，或者删除了不止一次。

解决方案便是返回一个智能指针而不是原始资源，而我们返回智能指针时就能指定 deleter 来自定义销毁动作：

```
shared_ptr<Investment> createInvestment(){
    // 销毁一项投资时，需要做一些取消投资的业务，而不是简单地`delete`
    return shared_ptr<Investment>(new Stock, getRidOfInvestment);
}
```

# 把类的设计视作类型设计

在面向对象的语言中，定义一个新 class 时，也就定义了一个新 type。实际上每一个类都需要你面对下面这些问题：

- 新的类型的对象应该如何创建和销毁？
- 对象的初始化和对象的赋值应该有什么不同？
- 以值传递对于你的新类型的对象意味着什么？
- 新类型的合法值的限定条件是什么？
- 新类型是否适合放进一个继承体系中？
- 新类型允许哪种类型转换？
  - 如果希望允许 T1 类型的对象隐式转型为 T2 类型的对象：
    - 在 T1 类中写一个类型转换函数（例如，operator T2），能够以单一参数调用。
    - 在 class T2 内写一个 non-explicit-one-argument（可被单一实参调用）的构造函数。
  - 希望仅仅允许显示转换：
    - 要写执行这个转换的函数，而且需要避免使它们的类型转换运算符或非显式构造函数能够以一个参数调用。
- 对于新类型哪些运算符和函数有意义？
- 新类型中哪些成员可以被访问？
- 新类型有多大程度的通用性？
  - 也许你并非定义一个新 type，而是定义一整个 types 家族。如果是这样就不应该定义一个新 class，而是应该定义一个新的 class template。
- 新的类型真的是你所需要的吗？
  - 可以仅仅定义一个新的继承类，以便让你可以为一个已存在的类增加一些功能。
  - 通过简单地定义一个或更多非成员函数或模板能否更好地达成你的目标。























