# 确定你的 public 继承塑模出 is a 关系

C++ 面向对象程序设计中，最重要的规则便是：public 继承应当是"is-a"的关系。当 Derived public 继承自 Base 时， 相当于你告诉编译器和所有看到你代码的人：Base 是 Derived 的抽象，Derived 就是一个 Base，任何时候Derived 都可以代替 Base使用。

 C++ 类的继承比现实世界中的继承关系更加严格：任何适用于父类的性质都要适用于子类！

Penguin 继承自 Bird，但企鹅不会飞：

```
class Bird{
public:
    vitural void fly();
};
class Penguin: public Bird{
    // fly??
};
```

Penguin 到底是否应该有 fly() 方法。但其实这个问题来源于自然语言的二义性： 严格地考虑，鸟会飞并不是所有鸟都会飞。我们对会飞的鸟单独建模便是：

```
class Bird{...};
class FlyingBird: public Bird{
public:
    virtual void fly();
};
class Penguin: public Bird{...};
```

这样当你调用 penguin.fly()  时便会编译错。当然另一种办法是  Penguin  继承自拥有 fly()  方法的 Bird， 但 Penguin::fly() 中抛出异常。这两种方式在概念是有区别的：

- 前者是说企鹅不能飞.
- 后者是说企鹅可以飞，但飞了会出错。

接口应当设计得不容易被误用，最好将错误从运行时提前到编译时。所以前者更好！

# 避免遮掩继承而来的名称

隐藏名称是作用域的问题。 在 C++ 中每一对`{}`都会开启一个新的作用域，并嵌套在当前作用域中。

```
int x;
void func(){
    double x;
    cin>>x;  //@ double x  隐藏了 int x
}
```

子类可以访问父类中的名称，是因为子类的作用域是嵌套在父类的作用域中的。 

```
class Base{
public:
    void func_base();
};
class Derived{
public:
    void func_derived(){
        func_base();
    }
};
```

在 func_derived() 中调用 func_base() 时：

- 编译器首先检查当前作用域内是否有名称 func_base 。
- 如果没有找到，然后去父作用域 Derived 中寻找名称 func_base 。
- 如果仍然未找到，然后去再上一级作用域 Base  中寻找 func_base，找到了！然后调用 Base::func_base()。
- 如果还没找到，编译器还会去 Derived 所在命名空间下、全局作用域下寻找。

子类中重写（override）与父类方法同名的方法，将会隐藏父类中所有同名的重载方法：

```
class Base{
public:
    virtual void func()=0;
    void func(int);
};
class Derived: public Base{
public:
    virtual void func();
};
...
Derived d;
d.func(1);      //@ 错误，Derived 中声明的 func 方法，隐藏了父类中所有的 func 名称
```

当你从父类继承来了一系列的重载方法，而只想重写其中的一个时，可以用 using，否则其他重载方法会被隐藏：

```
class Derived: public Base{
public:
    using Base::func;
    virtual void func();
};
...
d.func(1);      // OK
```

在 public 继承中，子类和父类是 "is-a" 的关系，所以通常我们希望从父类继承所有的方法。 但如果是 private 继承， 可能你只想要其中的一个，这时可以定义一个转调函数：

```
public:
	virtual void mf1() = 0;
	virtual void mf1(int);
};

class Derived : private Base {
public:
	virtual void mf1() {     //@ 转调函数
		Base::mf1(1);        //@ 这是一个inline函数
	}
};

Derived d;
int x;
d.mf1();		//@ 调用 Derived::mf1
d.mf1(x);		//@ 错误，Base::mf1 被遮掩了
```

# 区分接口继承和实现继承

 当你 public 继承一个类时，接口是一定会被继承的，你可以选择子类是否应当继承实现：

- 不继承实现，只继承方法接口：纯虚函数。
- 继承方法接口，以及默认的实现：虚函数。
- 继承方法接口，以及强制的实现：普通函数。

Rect  和 Ellipse 都继承自 Shape：

```
class Shape{
public:
    //@ 纯虚函数
    virtual void draw() const = 0;
    //@ 非纯虚函数
    virtual void error(const string& msg);
    //@ 普通函数
    int id() const;
};
class Rect: public Shape{...};
class Ellipse: public Shape{...};
```

public 继承，基类的成员函数接口总是会传递到子类。

- draw() 是一个纯虚函数，子类必须重新声明 draw 方法，同时父类不给任何实现。
- error() 是一个普通的虚函数，子类可以提供一个 error 方法，也可以使用默认的实现。
- id() 是一个普通函数，子类继承了这个接口，以及强制的实现方式。

因为像 ID 这种属性子类没必要去更改它，直接在父类中要求强制实现！

默认实现通常是子类中共同逻辑的抽象，显式地规约了子类的共同特性，避免了代码重复，方便了以后的增强，也便于长期的代码维护。

然而有时候提供默认实现是危险的，因为你不可预知会有怎样的子类添加进来。例如一个 Airplane 类以及它的几个 Model 子类：

```
class Airplane{
public:
    virtual void fly(){
    }
};
class ModelA: public Airplane{...};
class ModelB: public Airplane{...};
```

不难想象，我们写父类 Airplane 时，其中的 fly 是针对 ModelA 和 ModelB 实现了通用的逻辑。如果有一天我们加入了 ModelC 却忘记了重写 fly方法：

```
class ModelC: public Airplane{...};
Airplane* p = new ModelC;
p->fly();
```

这个设计问题的本质是普通虚函数提供了默认实现，而不管子类是否显式地声明它需要默认实现。

我们可以用另一个方法来给出默认实现，而把 fly 声明为纯虚函数，这样既能要求子类显式地重新声明一个 fly，当子类要求时又能提供默认的实现：

```
class Airplane{
public:
    virtual void fly() = 0;
protected:
    void defaultFly(){...}
}
class ModelA: public Airplane{
public:
    virtual void fly(){ defaultFly();}
}
class ModelB: public Airplane{
public:
    virtual void fly(){ defaultFly();}
}
```

这样当我们再写一个 ModelC 时，如果自己忘记了声明 fly() 会编译错，因为父类中的 fly() 是纯虚函数。 如果希望使用默认实现时可以直接调用 defaultFly()。

# 考虑 virtual 函数以外的其他选择















