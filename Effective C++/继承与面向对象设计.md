# 确定你的 public 继承塑模出 is a 关系

C++ 面向对象程序设计中，最重要的规则便是：public 继承应当是"is-a"的关系。当 Derived public 继承自 Base 时， 相当于你告诉编译器和所有看到你代码的人：Base 是 Derived 的抽象，Derived 就是一个 Base，任何时候Derived 都可以代替 Base使用。

 C++ 类的继承比现实世界中的继承关系更加严格：任何适用于父类的性质都要适用于子类！

Penguin 继承自 Bird，但企鹅不会飞：

```
class Bird{
public:
    vitural void fly();
};
class Penguin: public Bird{
    // fly??
};
```

Penguin 到底是否应该有 fly() 方法。但其实这个问题来源于自然语言的二义性： 严格地考虑，鸟会飞并不是所有鸟都会飞。我们对会飞的鸟单独建模便是：

```
class Bird{...};
class FlyingBird: public Bird{
public:
    virtual void fly();
};
class Penguin: public Bird{...};
```

这样当你调用 penguin.fly()  时便会编译错。当然另一种办法是  Penguin  继承自拥有 fly()  方法的 Bird， 但 Penguin::fly() 中抛出异常。这两种方式在概念是有区别的：

- 前者是说企鹅不能飞.
- 后者是说企鹅可以飞，但飞了会出错。

接口应当设计得不容易被误用，最好将错误从运行时提前到编译时。所以前者更好！

# 避免遮掩继承而来的名称

隐藏名称是作用域的问题。 在 C++ 中每一对`{}`都会开启一个新的作用域，并嵌套在当前作用域中。

```
int x;
void func(){
    double x;
    cin>>x;  //@ double x  隐藏了 int x
}
```

子类可以访问父类中的名称，是因为子类的作用域是嵌套在父类的作用域中的。 

```
class Base{
public:
    void func_base();
};
class Derived{
public:
    void func_derived(){
        func_base();
    }
};
```

在 func_derived() 中调用 func_base() 时：

- 编译器首先检查当前作用域内是否有名称 func_base 。
- 如果没有找到，然后去父作用域 Derived 中寻找名称 func_base 。
- 如果仍然未找到，然后去再上一级作用域 Base  中寻找 func_base，找到了！然后调用 Base::func_base()。
- 如果还没找到，编译器还会去 Derived 所在命名空间下、全局作用域下寻找。

子类中重写（override）与父类方法同名的方法，将会隐藏父类中所有同名的重载方法：

```
class Base{
public:
    virtual void func()=0;
    void func(int);
};
class Derived: public Base{
public:
    virtual void func();
};
...
Derived d;
d.func(1);      //@ 错误，Derived 中声明的 func 方法，隐藏了父类中所有的 func 名称
```

当你从父类继承来了一系列的重载方法，而只想重写其中的一个时，可以用 using，否则其他重载方法会被隐藏：

```
class Derived: public Base{
public:
    using Base::func;
    virtual void func();
};
...
d.func(1);      // OK
```

在 public 继承中，子类和父类是 "is-a" 的关系，所以通常我们希望从父类继承所有的方法。 但如果是 private 继承， 可能你只想要其中的一个，这时可以定义一个转调函数：

```
public:
	virtual void mf1() = 0;
	virtual void mf1(int);
};

class Derived : private Base {
public:
	virtual void mf1() {     //@ 转调函数
		Base::mf1(1);        //@ 这是一个inline函数
	}
};

Derived d;
int x;
d.mf1();		//@ 调用 Derived::mf1
d.mf1(x);		//@ 错误，Base::mf1 被遮掩了
```

# 区分接口继承和实现继承

 当你 public 继承一个类时，接口是一定会被继承的，你可以选择子类是否应当继承实现：

- 不继承实现，只继承方法接口：纯虚函数。
- 继承方法接口，以及默认的实现：虚函数。
- 继承方法接口，以及强制的实现：普通函数。

Rect  和 Ellipse 都继承自 Shape：

```
class Shape{
public:
    //@ 纯虚函数
    virtual void draw() const = 0;
    //@ 非纯虚函数
    virtual void error(const string& msg);
    //@ 普通函数
    int id() const;
};
class Rect: public Shape{...};
class Ellipse: public Shape{...};
```

public 继承，基类的成员函数接口总是会传递到子类。

- draw() 是一个纯虚函数，子类必须重新声明 draw 方法，同时父类不给任何实现。
- error() 是一个普通的虚函数，子类可以提供一个 error 方法，也可以使用默认的实现。
- id() 是一个普通函数，子类继承了这个接口，以及强制的实现方式。

因为像 ID 这种属性子类没必要去更改它，直接在父类中要求强制实现！

默认实现通常是子类中共同逻辑的抽象，显式地规约了子类的共同特性，避免了代码重复，方便了以后的增强，也便于长期的代码维护。

然而有时候提供默认实现是危险的，因为你不可预知会有怎样的子类添加进来。例如一个 Airplane 类以及它的几个 Model 子类：

```
class Airplane{
public:
    virtual void fly(){
    }
};
class ModelA: public Airplane{...};
class ModelB: public Airplane{...};
```

不难想象，我们写父类 Airplane 时，其中的 fly 是针对 ModelA 和 ModelB 实现了通用的逻辑。如果有一天我们加入了 ModelC 却忘记了重写 fly方法：

```
class ModelC: public Airplane{...};
Airplane* p = new ModelC;
p->fly();
```

这个设计问题的本质是普通虚函数提供了默认实现，而不管子类是否显式地声明它需要默认实现。

我们可以用另一个方法来给出默认实现，而把 fly 声明为纯虚函数，这样既能要求子类显式地重新声明一个 fly，当子类要求时又能提供默认的实现：

```
class Airplane{
public:
    virtual void fly() = 0;
protected:
    void defaultFly(){...}
}
class ModelA: public Airplane{
public:
    virtual void fly(){ defaultFly();}
}
class ModelB: public Airplane{
public:
    virtual void fly(){ defaultFly();}
}
```

这样当我们再写一个 ModelC 时，如果自己忘记了声明 fly() 会编译错，因为父类中的 fly() 是纯虚函数。 如果希望使用默认实现时可以直接调用 defaultFly()。

# 考虑 virtual 函数以外的其他选择

假如现在正在写一个游戏，游戏中人物的血量随着战斗而减少，用一个函数 healthValue 返回这个血量值。因为不同人物血量值计算方法不同，所以应该讲 healthValue 声明为 virtual：

```
class GameCharacter{
public:
    virtual int healthValue() const;	//@ 派生类可以重新定义
    //@ ……
};
```

这样的实现使得我们不会考虑其他的方法，但是其实有很多的替代方案：

- 藉由 Non-virtual Interface 手法实现 Template Method 模式，用非虚函数来调用更加封装的虚函数。
- 藉由 Function Pointers 实现 Strategy 模式。
- 藉由 std::function 完成 Strategy 模式。
- 古典的 Strategy 模式。

## NVI 实现模板方法模式

先看一个主张：virtual 函数应该几乎总是 private。这个主张建议，较好的设计是保留 healthValue 为 public non-virtual 成员函数，让它调用一个 private virtual 函数来做实际工作：

```
class GameCharacter {
public:
	GameCharacter() =  default;
	~GameCharacter() = default;

public:
	//@ 子类不应重新定义该方法
	int healthValue() const {
		//@ 事前工作
		int ret = doHealthValue();
		//@ 事后工作
		return ret;
	}
private:
	//@ 子类可以重新定义该方法
	virtual int doHealthValue() const {
		std::cout << __func__ << std::endl;
		return 0;
	}
};

//@ 武士
class Warrior : public GameCharacter
{
private:
	//@ 子类可以重新定义该方法
	virtual int doHealthValue() const override{
		std::cout << "Warrior::doHealthValue" << std::endl;
		return 80;
	}
};

//@ 法师
class Mage : public GameCharacter
{
private:
	//@ 子类可以重新定义该方法
	virtual int doHealthValue() const override {
		std::cout << "Mage::doHealthValue" << std::endl;
		return 100;
	}
};

//@ 调用
GameCharacter* c1 = new Warrior();
GameCharacter* c2 = new Mage();

c1->healthValue();
c2->healthValue();
```

这个设计是让客户通过 public non-virtual 成员函数间接调用 private virtual 函数，成为 non-virtual interface（NVI）手法。它是所谓 Template Method 设计模式。这个 non-virtual 函数叫做 virtual 函数的外覆器（wrapper）。

NVI Idiom的好处在于：

- 在调用 doHealthValue 前可以做一些设置上下文的工作，调用后可以清除上下文。 比如在调用前给互斥量（mutex）加锁、验证前置条件、类的不变式。
- 调用后给互斥量解锁、验证后置条件、类的不变式等。

doHealthValue 在子类中是不可调用的，然而子类却重写了它。 但 C++ 允许这样做是有充分理由的：

- 父类拥有何时调用该接口的权利；
- 子类拥有如何实现该接口的权利。

有时为了继承实现方式，子类虚函数会调用父类虚函数，这时 doHealthValue 就需要是 protected 了。 有时（比如析构函数）虚函数还必须是 public，那么就不能使用 NVI 了。

## 函数指针实现策略模式

上述的 NVI 随是实现了模板方法，但事实上还是在用虚函数。我们甚至可以让 healthValue() 完全独立于角色的类，只在构造函数时把该函数作为参数传入。

```
class GameCharacter;
 
int defaultHealthCalc(const GameCharacter& gc); //@ healthValue 缺省算法
 
class GameCharacter{
public:
    typedef int (*HealthCalcFunc)(const GameCharacter&);
    explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc): healthFunc(hcf){}
    int healthValue() const{
        return healthFunc(*this);
    }
private:
    HealthCalcFunc healthFunc;	//@ 函数指针
}
```

这便实现了策略模式。可以在运行时指定每个对象的生命值计算策略，比虚函数的实现方式有更大的灵活性：

- 同一人物类型之不同实体可以有不同的健康计算函数，只需要在构造时传入不同策略即可。也就是说同一人物类型不同的对象可以有不同的健康计算，例如射击游戏中，一些购买防弹衣的玩家使用的对象，血量可以减少更慢。
- 某已知人物健康计算函数可以在运行期间变更，只需要提供一个 setHealthCalculator 成员方法即可。即健康计算函数不再是GameCharacter继承体系内的成员函数。

我们使用外部函数实现了策略模式，但因为 defaultHealthCalc 是外部函数，所以无法访问类的私有成员。 如果它通过 public 成员便可以实现的话就没有任何问题了，如果需要内部细节，只能弱化 GameCharacter 的封装。或者提供更多 public 成员，或者将 defaultHealthCalc 设为 friend。 弱化的封装和更灵活的策略是一个需要权衡的设计问题，取决于实际问题中动态策略的需求有多大。

## function 实现策略模式

使用 function 代替函数指针！function 是一个对象， 他可以保存任何一种类型兼容的可调用的实体（callable entity）例如函数对象、成员函数指针等。 看代码：

```
class GameCharacter;
int defaultHealthCalc(const GameCharacter& gc);
 
class GameCharacter{
public:
    typedef std::function<int (const GameCharacter&)> HealthCalcFunc;
    explicit GameCaracter(HealthCalcFunc hcf = defaultHealthCalc): healthCalcFunc(hcf){}
    int healthValue() const{
        return healthFunc(*this);
    }
private:
    HealthCalcFunc healthFunc;
};
```

注意 std::function 的模板参数是 int (const GameCharacter&)，参数是 GameCharacter 的引用返回值是 int， 但 healthCalcFunc 可以接受任何与该签名兼容的可调用实体。即只要参数可以隐式转换为 GameCharacter 返回值可以隐式转换为 int 就可以。 用 function 代替函数指针后客户代码可以更加灵活：

```
// 类型兼容的函数
short calcHealth(const GameCharacter&);
// 函数对象
struct HealthCalculator{
    int operator()(const GameCharacter&) const{...}
};
// 成员函数
class GameLevel{
public:
    float health(const GameCharacter&) const;
};
```

无论是类型兼容的函数、函数对象还是成员函数，现在都可以用来初始化一个 GameCharacter 对象：

```
GameCharacter evil, good, bad;
// 函数
evil(calcHealth);                       
// 函数对象
good(HealthCalculator());
// 成员函数
GameLevel currentLevel;
bad(std::bind(&GameLevel::health, currentLevel, _1));
```

GameLevel::health 接受一个参数 const GameCharacter&， 但事实上在运行时它是需要两个参数的，const GameCharacter& 以及 this。只是编译器把后者隐藏掉了。 那么std::bind 的语义就清楚了：首先它指定了要调用的方法是 GameLevel::health，第一个参数是 currentLevel，this 是_1，即 &currentLevel。

## 经典的策略模式

在 UML 表示中，生命值计算函数 HealthCalcFunc 应当定义为一个类，拥有自己的类层级。 它的成员方法 calc 应当为虚函数，并在子类可以有不同的实现。

```
class HealthCalcFunc{
public:
    virtual int calc(const CameCharacter& gc) const;
};
HealthCalcFunc defaultHealthCalc;
class GameCharacter{
public:
    explicit GameCharacter(HealthCalcFunc *phcf = &defaultHealthCalc): pHealthCalc(phcf)     {}
    int healthValue() const{
        return pHealthCalc->calc(*this);
    }
private:
    HealthCalcFunc *pHealthCalc;
};
```

# 绝不要重新定义继承而来的 non-virtual 函数





































