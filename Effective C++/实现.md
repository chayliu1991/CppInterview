# 尽可能推迟变量的定义

存在控制流转移的代码中，你可能会不经意间定义无用的变量。例如：

```
string encryptPassword(const string& password){
    string encrypted;
    if (password.length() < MinimumPasswordLength) {
        throw logic_error("Password is too short");
    }
    encrypted = password;
    encrypt(encrypted);
    return encrypted;
}
```

当抛出异常时，encrypted 是无用的根本不需要构造它。所以更好的写法是推迟 encrypted 的构造：

```
string encryptPassword(const string& password){
    if (password.length() < MinimumPasswordLength) {
        throw logic_error("Password is too short");
    }
    string encrypted;       //@ 默认构造函数
    encrypted = password;   //@ 赋值运算符
    encrypt(encrypted);
    return encrypted;
}
```

构造一个对象再给它赋值不如直接用一个值初始化它， 所以上述代码还有改进的余地：直接用 password 来初始化 encrypted：

```
string encryptPassword(const string& password){
    if (password.length() < MinimumPasswordLength) {
       throw logic_error("Password is too short");
    }
    string encrypted(password);     //@ 拷贝构造函数
    encrypt(encrypted);
    return encrypted;
}
```

循环中的变量定义也是一个常见的争论点。这里援引 Scott Meyers 的例子，比如我们有两种写法：

写法A，在循环外定义：

```
Widget w;
for (int i = 0; i < n; ++i){ 
  w = some value dependent on i;
  ...                           
}
```

写法B，在循环内定义：

```
for (int i = 0; i < n; ++i) {
    Widget w(some value dependent on i);
    ...
}
```

- 写法A的代价是：1个构造函数，1个析构函数，n个赋值运算符
- 写法B的代价是：n个构造函数，n个析构函数

但 A 使得循环内才使用的变量进入外部的作用域，不利于程序的理解和维护。软件工程中倾向于认为人的效率比机器的效率更加难得， 所以推荐采用B来实现。除非这段代码是性能的关键，并且赋值比一对构造/析构更加廉价。

# 尽量少做类型转换

## 旧风格的强制类型转换

- C 风格的类型转换：

```
(T) expression
```

- 函数风格的类型转换：

```
T(expression)
```

以上两种形式之间没有本质上的不同，它纯粹就是一个把括号放在哪的问题。

## C++ 中的四种新的强制类型转换

C++ 中提供四种新式类型转换：

```
const_cast<T>(expression)
dynamic_cast<T>(expression)
reinterpret_cast<T>(expression)
static_cast<T>(expression)
```

- const_cast 一般用于强制消除对象的常量性。它是唯一能做到这一点的 C++ 风格的强制转型。
- dynamic_cast 主要用于执行“安全的向下转型”，也就是说，要确定一个对象是否是一个继承体系中的一个特定类型。它是唯一不能用旧风格语法执行的强制转型。也是唯一可能有重大运行时代价的强制转型。
- reinterpret_cast 是特意用于底层的强制转型，导致实现依赖（就是说不可移植）的结果，例如，将一个指针转型为一个整数。这样的强制转型在底层代码以外应该极为罕见。
- static_cast 可以被用于强制隐型转换：
  - non-const 对象转型为 const 对象
  - int 转型为 double
  - void* 指针转型为有类型指针
  - 基类指针转型为派生类指针
  - 它不能将一个 const 对象转型为 non-const 对象（只有 const_cast 能做到）

## 提倡使用新式 C++ 风格类型转换

- 新式转型很容易被辨识出来，可以很快找到代码中有哪些转型。
- 新式转型语义更加明确（编译器会做更详细的检查）不容易误用。

## dynamic_cast 的性能问题

之所以需要 dynamic_cast ，通常是因为你想在一个你认为 derived class 对象身上执行 derived class 操作函数，但是你手上只用一个指向 base 的指针或引用，你只能靠它们来处理对象。

在一般的实现中 dynamic_cast 会逐级地比较类名。连续的 dynamic_cast 一定要避免，比如这样：

 ```
class Window{...};
//@ ...
typedef std::vector<std::tr1::shared_ptr<Window>> VPW;
VPW winPtrs;
//@ ...
for(VPW::iterator iter = winPtrs.begind(); iter != winPtrs.end(); ++iter)
{
	if (SpecialWindow1 *p = dynamic_cast<SpecialWindow1*>(it->get()) { ... }
	else if (SpecialWindow2 *p = dynamic_cast<SpecialWindow2*>(it->get()) { ... }
	else if (SpecialWindow3 *p = dynamic_cast<SpecialWindow3*>(it->get()) { ... }
	//@ ...
}
 ```

# 避免返回对象内部的句柄

句柄（handle）可以理解为持有其它对象的方法，引用，指针，和迭代器都是句柄。

不要返回对象私有成员的句柄。这样可以增加类的封装性、使得 const 函数更加 const， 也避免了空引用的创建。

直接返回私有成员的指针会导致私有成员被完全暴露。例如：

```
class Point {                    
public:
  Point(int x, int y);
  ...

  void setX(int newVal);
  void setY(int newVal);
  ...
};

struct RectData {                 
  Point ulhc;                     
  Point lrhc;                    
};

class Rectangle {
  ...
  Point& upperLeft() const { return pData->ulhc; }
  Point& lowerRight() const { return pData->lrhc; }
  ...
  
private:
  std::tr1::shared_ptr<RectData> pData;          // see Item 13 for info on
};  
```

一方面，upperLeft 和 lowerRight 是被声明为 const 的成员函数，因为它们被设计成仅仅给客户提供一个获得 Rectangle 的点的方法，而不允许客户改变这个 Rectangle。

另一方面，两个函数都返回引向私有的内部数据的引用——调用者可以利用这些引用修改内部数据。

将 const 用于它们的返回类型：

```
class Rectangle {
public:
  ...
  const Point& upperLeft() const { return pData->ulhc; }
  const Point& lowerRight() const { return pData->lrhc; }
  ...
};
```

# 追求异常安全的代码











