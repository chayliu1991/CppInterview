# strcpy

```
char* Strcpy(char* dst,const char* src)
{
	assert((dst != NULL) && (src != NULL));
	char* res = dst;
	//@ 后缀++ 优先于解引用* 运算符
	//@ 会拷贝 '\0' 到目的字符串
	while ((*dst++ = *src++) != '\0')
		;
	return res;
}
```

- 要确保 dst 有足够的空间容纳 src
- dst 和 src 空间不能重叠
- 返回 char* 是为了满足链式表达式
- 会从 src 拷贝 '\0' 到 dst

# strlen

```
int Strlen(const char* str)
{
	assert(str != NULL);
	int res = 0;
	while (*str++ != '\0')
		res++;
	return res;
}
```

- strlen 计算字符串长度，字符串必须是以 '\0' 结尾

# strcat

```
char* Strcat(char* dst,const char* src)
{
	assert((dst != NULL) && (src != NULL));
	char* res = dst;
	while (*dst != '\0')
		dst++;
	while ((*dst++ = *src++) != '\0')
		;
	return res;
}
```

- 要确保 dst 有足够的空间容纳 src
- dst 和 src 空间不能重叠
- 返回 char* 是为了满足链式表达式
- 会从 src 拷贝 '\0' 到 dst

# strcmp

```
int Strcmp(const char *s1, const char *s2)
{
	assert((s1 != NULL) && (s2 != NULL));
	while (*s1 == *s2)
	{
		if (*s1 == '\0')
			return 0;
		++s1;
		++s2;
	}
	return (*s1 - *s2) > 0 ? 1 :-1;
}
```

- 两个字符串自左向右逐个字符相比（按ASCII值大小相比较），直到出现不同的字符或遇 \0 为止
  - 若 s1 == s2，返回零
  - 若 s1 > s2，返回正数
  - 若 s1 < s2，返回负数

# strncpy 

```
char *Strncpy(char *dst, const char *src, size_t n)
{
	assert((dst != NULL) && (src != NULL));
	size_t i;
	for (i = 0; i < n && src[i] != '\0'; i++)
		dst[i] = src[i];
	for (; i < n; i++)
		dst[i] = '\0';
	return dst;
}
```

- 如果 src 的长度小于 n，dst 剩余的字节会被 '\0' 填充

- 如果 src 的长度大于 n，dst 的末尾不会添加 '\0'，因此，通常在使用 strncpy 时：

```
memset(dst, 0, MAX);   //@ 使用之前先将 dst 空间清0，有些浪费
dst[MAX-1] = '\0';     //@ 使用之后将 dst 末尾置 '\0'
```
#  sprintf  和 snprintf

sprintf  也可以用于字符串的拷贝：

```
sprintf(dst, "%s", src);
```

- 需要保证 dst 有足够的空间

snprintf 用于字符串拷贝是一种即简洁又安全的方式：

```
char buf[MAX]; 
snprintf(buf, sizeof(buf), "%s", src);
```

- snprintf 的特点是安全，不管怎么着，它都能保证结果串 buf 以 '\0' 结尾
- 返回值表示要写入的字符串长度 

# memcpy

```
void* Memecpy(void* dst,const void* src,size_t count)
{
	assert((dst != NULL) && (src != NULL));
	unsigned char* pdst = (unsigned char*)dst;
	const unsigned char* psrc = (const unsigned char*)src;

	//@ 检查内存重叠
	if (pdst >= psrc && pdst < psrc + count || psrc >= pdst && psrc < pdst + count)
		return NULL;
	while (count--)
	{
		*pdst = *psrc;
		pdst++;
		psrc++;
	}
	return dst;
}
```

- dst 和 src 所指内存区域不能重叠
- 与 strcpy 相比，memcpy 并不是遇到 '\0' 就结束，而是一定会拷贝完 count 个字节
- 性能方面： strncpy() 最差，snprintf 次之，memcpy 性能最佳，因此任何时候不要考虑使用 strncpy

优化：

```
void* Memecpy2(void* dst, const void* src, size_t count)
{
	assert((dst != NULL) && (src != NULL));
	//@ 检查内存重叠
	bool flag1 = (char*)dst >= (char*)src && (char*)dst < (char*)src + count;
	bool flag2 = (char*)src >= (char*)dst && (char*)src < (char*)dst + count;
	if (flag1 || flag2)
		return NULL;

	size_t wordCount = count / 4, byteCount = count % 4;
	int* pWorddst = (int*)dst;
	const int* pWordsrc = (int*)src;

	while (wordCount--)
		*pWorddst++ = *pWordsrc++;
		
	char* pBytedst = (char*)pWorddst;
	const char* pBytesrc = (char*)pWordsrc;
	while (byteCount--)
		*pBytedst++ = *pBytesrc++;
	return dst;
}
```

- 地址不对齐时，memcpy 会逐字节拷贝，但是地址对齐时，一般使用 CPU 字长来 copy，上面展示按照 CPU 字长为4进行copy

# memmove

https://segmentfault.com/a/1190000011265793



# memset






























