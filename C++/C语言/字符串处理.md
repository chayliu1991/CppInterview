# strcpy

```
char* Strcpy(char* dst,const char* src)
{
	assert((dst != NULL) && (src != NULL));
	char* res = dst;
	//@ 后缀++ 优先于解引用* 运算符
	//@ 会拷贝 '\0' 到目的字符串
	while ((*dst++ = *src++) != '\0')
		;
	return res;
}
```

- 要确保 dst 有足够的空间容纳 src
- dst 和 src 空间不能重叠
- 返回 char* 是为了满足链式表达式
- 会从 src 拷贝 '\0' 到 dst

# strlen

```
int Strlen(const char* str)
{
	assert(str != NULL);
	int res = 0;
	while (*str++ != '\0')
		res++;
	return res;
}
```

- strlen 计算字符串长度，字符串必须是以 '\0' 结尾

# strcat

```
char* Strcat(char* dst,const char* src)
{
	assert((dst != NULL) && (src != NULL));
	char* res = dst;
	while (*dst != '\0')
		dst++;
	while ((*dst++ = *src++) != '\0')
		;
	return res;
}
```

- 要确保 dst 有足够的空间容纳 src
- dst 和 src 空间不能重叠
- 返回 char* 是为了满足链式表达式
- 会从 src 拷贝 '\0' 到 dst

# strcmp

```
int Strcmp(const char *s1, const char *s2)
{
	assert((s1 != NULL) && (s2 != NULL));
	while (*s1 == *s2)
	{
		if (*s1 == '\0')
			return 0;
		++s1;
		++s2;
	}
	return (*s1 - *s2) > 0 ? 1 :-1;
}
```

- 两个字符串自左向右逐个字符相比（按ASCII值大小相比较），直到出现不同的字符或遇 \0 为止
  - 若 s1 == s2，返回零
  - 若 s1 > s2，返回正数
  - 若 s1 < s2，返回负数

# strncpy 

```
char *Strncpy(char *dst, const char *src, size_t n)
{
	assert((dst != NULL) && (src != NULL));
	size_t i;
	for (i = 0; i < n && src[i] != '\0'; i++)
		dst[i] = src[i];
	for (; i < n; i++)
		dst[i] = '\0';
	return dst;
}
```

- 如果 src 的长度小于 n，dst 剩余的字节会被 '\0' 填充

- 如果 src 的长度大于 n，dst 的末尾不会添加 '\0'，因此，通常在使用 strncpy 时：

```
memset(dst, 0, MAX);   //@ 使用之前先将 dst 空间清0，有些浪费
dst[MAX-1] = '\0';     //@ 使用之后将 dst 末尾置 '\0'
```
#  sprintf  和 snprintf

sprintf  也可以用于字符串的拷贝：

```
sprintf(dst, "%s", src);
```

- 需要保证 dst 有足够的空间

snprintf 用于字符串拷贝是一种即简洁又安全的方式：

```
char buf[MAX]; 
snprintf(buf, sizeof(buf), "%s", src);
```

- snprintf 会把 buf 的最后一个位置保留为 '\0'
- 返回值表示要写入的字符串长度






























