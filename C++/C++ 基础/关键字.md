# static

## 全局静态变量
在全局变量前加上关键字 `static`，全局变量就定义成一个全局静态变量。

- 静态存储区，在整个程序运行期间一直存在
- 未经初始化的全局静态变量会被自动初始化为0
- 全局静态变量在声明它的文件之外是不可见的，准确地说其作用域是从定义之处开始，到文件结尾

## 局部静态变量

在局部变量之前加上关键字 `static`，局部变量就成为一个局部静态变量。

- 不分配在堆或者栈上，而是存放在静态存储区
- 未经初始化的全局静态变量会被自动初始化为0
- 作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值为上一次保留的结果

## 静态函数

在函数返回类型前加static，函数就定义为静态函数。

- 函数的定义和声明在默认情况下都是 `extern` 的，但静态函数只是在声明他的文件当中可见，不能被其他文件所使用，函数命名不会同其他 `cpp` 中的同名函数引起冲突
- 一般来说，不要再头文件中声明static的全局函数，不要在 `cpp` 内声明非 `static` 的全局函数

## 类的静态成员

在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性

- 静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用
- 可以实施封装，`static` 成员可以是私有的，而全局对象不可以
- 静态数据成员与类的大小无关，因为静态成员只是作用在类的范围而已
- 未经初始化的全局静态变量会被自动初始化为0

### 类静态成员初始化

类的静态成员不能在类中直接初始化：

```
class Test
{
public:
	static int a = 1; //@ error
}
```

这是因为C++要求每个对象都有唯一的定义，不然编译器不知道该把这个对象放在哪个内存地址。如果在Test里面初始化静态成员，那么实例化每个类Test的对象时都相当于定义了一次这个静态成员，这就违反了上述规则。

类的静态成员不能在类外初始化：

````
class Test
{
public:
	static int a;
}

int Test::a = 1; //@ 初始化
````

类外初始化时候，不需要使用 `static` 关键字，因为在文件中的 `static` 表示作用域在本文件内。

另外，如果不在类外初始化类的静态成员，是无法对其取地址的：

```
class Test
{
public:
	static int a;
}

int main()
{
	cout << &Test::a << endl;  //@ error
	return 0;
}
```

### const  静态成员

- 可以在类内初始化也可以在类外初始化

```
struct X
{
	const static int  n = 1;
	const static int m{ 2 };//@ since C++11
	const static int k;
};
const int X::k = 3;  
```

### constexpr 静态成员

- 必须在类内初始化

```
struct X
{
	constexpr static int  arr[] = {1,2,3};
	constexpr static std::complex<double> c{ 1,3 };
	constexpr static int k; //@ error,必须初始化
};
```

## 类的静态函数 

静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。

- 因为 `static` 成员函数没有 `this` 指针，所以静态成员函数不可以访问非静态成员(静态数据成员，静态成员函数)
- 非静态成员函数可以访问静态成员

### static 成员函数不能是虚函数

`static` 函数属于静态联编即在编译时候就绑定成功；而 `virtual` 函数属于动态联编，通过相应对象中的虚函数表指针需找到相应的虚函数指针，完成动态绑定。关键之处在于 `static` 函数没有 `this` 指针，属于类而不属于具体对象。

### static 成员函数不能使用 CV 限定符

```
class A
{
public:
	void f1() volatile { cout << "f1" << endl; }; //@ ok
	void f2() const { cout << "f1" << endl; }; //@ ok
	static void f3() volatile { cout << "f1" << endl; }; //@ error
	static void f4() const { cout << "f1" << endl; }; //@ error
};
```

# extern

## extern 用于变量声明和定义

为了支持分离式编译，C++ 允许将声明和定义分离开来。变量的声明规定了变量的类型和名字，使一个名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。定义则负责创建与名字关联的实体，定义还申请存储空间。

如果想声明一个变量而非定义它，就在变量名前添加 `extern` 关键字，而且不要显式地初始化变量：

```
extern int i;  //@ 声明i而非定义
int j;         //@ 声明并定义i
```

如果给 `extern` 关键字标记的变量赋一个初始值，就将变成定义，而非声明：

```
extern int v = 2;
int v = 2;     //@ 这两个语句效果完全一样，都是v的定义
```

变量能且只能被定义一次，但是可以被声明多次。

## 使用 extern 在多个文件中共享 const 对象

默认情况下，一个 `const` 对象仅在本文件内有效，如果多个文件中出现了同名的 `const` 变量时，其实等同于在不同的文件中分别定义了独立的变量。

某些时候有这样一种 `const` 变量，它的初始值不是一个常量表达式，但又确实有必要在文件间共享。这种情况下，我们不希望编译器为每个文件分别生成独立的变量。我们想让这类 `const` 对象像其他非常量对象一样工作，也就是说，只在一个文件中定义 `const`，而在其他多个文件中声明并使用它。

方法是对于 `const` 变量不管是声明还是定义都添加 `extern` 关键字，这样只需要定义一次就可以了：

```
//@ file1.cpp定义并初始化和一个常量，该常量能被其他文件访问
extern const int bufferSize = function();
//@ file1.h头文件
extern const int bufferSize; //@ 与file1.cpp中定义的是同一个
```

## 模板的控制实例化

当两个或者多个独立编译的源文件中使用了相同的模板并且提供了相同的模板参数时，每个文件中都会有该模板的一个实例。

在大系统中，在多个文件中实例化相同的模板的额外开销可能非常严重，在C++11新标准中，我们可以通过显式实例化来避免这种开销。一个显式实例化具有如下形式：

```
extern template declaration; //@ 实例化声明
template declaration;        //@ 实例化定义
```

`declaration` 是一个类或函数的声明，其中所有的模板参数都已经被替换成为模板实参。例如：

```
extern template class vec<string>;       //@ 声明
template int sum(const int, const int);  //@ 定义
```

当编译器遇到 `extern`模板声明时，它不会在本文件中生成实例化代码，将一个实例化声明为 `extern` 就表示承诺在程序的其他位置有该实例化的一个非 `extern` 定义。对于一个给定的实例化版本，可能有多个 `extern` 声明，但必须只有一个定义。

由于编译器在使用一个模板时自动对其实例化，因此 `extern` 声明必须出现在任何使用此实例化吧版本的代码之前。

## extern  "C"

被 `extern "C"` 修饰的变量和函数是按照 C 语言方式进行编译和链接的：这点很重要。

由于 C++ 支持函数重载，而C语言不支持，因此函数被 C++ 编译后在符号库中的名字是与 C 语言不同的；C++ 编译后的函数需要加上参数的类型才能唯一标定重载后的函数，而加上 `extern "C"` 后，是为了向编译器指明这段代码按照 C 语言的方式进行编译。





# virtual

## 哪些函数不能是虚函数

### 内联函数不能是 virtual

内联函数是在编译时期展开，而虚函数的特性是运行时才动态联编,所以两者矛盾，不能定义内联函数为虚函数。

虚表机制需要一个真正的函数地址，而内联函数展开以后，就不是一个函数，而是一段简单的代码。

### 构造函数不能是 virtual

构造函数用来创建一个新的对象，而虚函数的运行是建立在对象的基础上，在构造函数执行时，对象尚未形成，所以不能将构造函数定义为虚函数。

虚函数对应一个指向`vtable`虚函数表的指针，虚函数的执行依赖于虚函数表。而虚函数表在构造函数中进行初始化工作，即初始化`vptr`，让他指向正确的虚函数表。而在构造对象期间，虚函数表还没有被初始化，将无法进行。

### 静态成员函数不能是virtual

静态成员函数属于一个类而非某一对象，没有 `this`指针，它无法进行对象的判别。

### 友元函数
因为`C++`不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。



































