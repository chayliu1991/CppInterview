# static

## 全局静态变量
在全局变量前加上关键字 `static`，全局变量就定义成一个全局静态变量。

- 静态存储区，在整个程序运行期间一直存在
- 未经初始化的全局静态变量会被自动初始化为0
- 全局静态变量在声明它的文件之外是不可见的，准确地说其作用域是从定义之处开始，到文件结尾

## 局部静态变量

在局部变量之前加上关键字 `static`，局部变量就成为一个局部静态变量。

- 不分配在堆或者栈上，而是存放在静态存储区
- 未经初始化的全局静态变量会被自动初始化为0
- 作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值为上一次保留的结果

## 静态函数

在函数返回类型前加static，函数就定义为静态函数。

- 函数的定义和声明在默认情况下都是 `extern` 的，但静态函数只是在声明他的文件当中可见，不能被其他文件所使用，函数命名不会同其他 `cpp` 中的同名函数引起冲突
- 一般来说，不要再头文件中声明static的全局函数，不要在 `cpp` 内声明非 `static` 的全局函数

## 类的静态成员

在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性

- 静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用
- 可以实施封装，`static` 成员可以是私有的，而全局对象不可以
- 静态数据成员与类的大小无关，因为静态成员只是作用在类的范围而已
- 未经初始化的全局静态变量会被自动初始化为0

### 类静态成员初始化

类的静态成员不能在类中直接初始化：

```
class Test
{
public:
	static int a = 1; //@ error
}
```

这是因为C++要求每个对象都有唯一的定义，不然编译器不知道该把这个对象放在哪个内存地址。如果在Test里面初始化静态成员，那么实例化每个类Test的对象时都相当于定义了一次这个静态成员，这就违反了上述规则。

类的静态成员不能在类外初始化：

````
class Test
{
public:
	static int a;
}

int Test::a = 1; //@ 初始化
````

类外初始化时候，不需要使用 `static` 关键字，因为在文件中的 `static` 表示作用域在本文件内。

另外，如果不在类外初始化类的静态成员，是无法对其取地址的：

```
class Test
{
public:
	static int a;
}

int main()
{
	cout << &Test::a << endl;  //@ error
	return 0;
}
```

### const  静态成员

- 可以在类内初始化也可以在类外初始化

```
struct X
{
	const static int  n = 1;
	const static int m{ 2 };//@ since C++11
	const static int k;
};
const int X::k = 3;  
```

### constexpr 静态成员

- 必须在类内初始化

```
struct X
{
	constexpr static int  arr[] = {1,2,3};
	constexpr static std::complex<double> c{ 1,3 };
	constexpr static int k; //@ error,必须初始化
};
```

## 类的静态函数 

静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。

- 因为 `static` 成员函数没有 `this` 指针，所以静态成员函数不可以访问非静态成员(静态数据成员，静态成员函数)
- 非静态成员函数可以访问静态成员

### static 成员函数不能是虚函数

`static` 函数属于静态联编即在编译时候就绑定成功；而 `virtual` 函数属于动态联编，通过相应对象中的虚函数表指针需找到相应的虚函数指针，完成动态绑定。关键之处在于 `static` 函数没有 `this` 指针，属于类而不属于具体对象。

### static 成员函数不能使用 CV 限定符

```
class A
{
public:
	void f1() volatile { cout << "f1" << endl; }; //@ ok
	void f2() const { cout << "f1" << endl; }; //@ ok
	static void f3() volatile { cout << "f1" << endl; }; //@ error
	static void f4() const { cout << "f1" << endl; }; //@ error
};
```

# extern



# virtual

## 哪些函数不能是虚函数

### 内联函数不能是 virtual

内联函数是在编译时期展开，而虚函数的特性是运行时才动态联编,所以两者矛盾，不能定义内联函数为虚函数。

虚表机制需要一个真正的函数地址，而内联函数展开以后，就不是一个函数，而是一段简单的代码。

### 构造函数不能是 virtual

构造函数用来创建一个新的对象，而虚函数的运行是建立在对象的基础上，在构造函数执行时，对象尚未形成，所以不能将构造函数定义为虚函数。

虚函数对应一个指向`vtable`虚函数表的指针，虚函数的执行依赖于虚函数表。而虚函数表在构造函数中进行初始化工作，即初始化`vptr`，让他指向正确的虚函数表。而在构造对象期间，虚函数表还没有被初始化，将无法进行。

### 静态成员函数不能是virtual

静态成员函数属于一个类而非某一对象，没有 `this`指针，它无法进行对象的判别。

### 友元函数
因为`C++`不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。



































