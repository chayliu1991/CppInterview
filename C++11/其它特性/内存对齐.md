# 内存对齐介绍

内存对齐是一个数据类型所能存放的内存地址的属性，这个属性是无符号整数，并且这个整数必须是 2 的 N 次方，当说一个数据类型的内存对齐为 8 时，就是指这个数据类型所定义出来的所有变量的内存地址都是 8 的倍数。

当一个基本数据类型的对齐属性和这个数据类型的大小相等时，这种对齐方式称为自然对齐，比如一个 4 字节大小的 int 型数据，在默认情况下它的字节对齐方式是 4。

为什么需要内存对齐？

- 不是每一个硬件平台都能随意访问任意的内存，一些硬件平台读取的数据如果是未对齐的将会拒绝访问或者抛出硬件异常。
- 考虑到 CPU 处理内存的方式，内存对齐将会提高数据的读取效率。

因为内存对齐，所以数据在内存中的存放不是紧挨着的，而是会出现一些空隙(空白填充)，这对基本数据类型来说还能接受，但是对于结构体或类而言，sizeof 的结果往往和想象中不一样：

```
struct MyStruct
{
	char  c1;	//@ 1 bytes
	int   i;	//@ 4 bytes
	short s;	//@ 2 bytes
	long  long  ll; //@ 8 bytes
	char  c2; //@ 1 bytes
}; //@ total 16 bytes

int main()
{
	//@ MSVC 编译器 32 bytes，不同的平台对齐方式可能不一样  
	std::cout << sizeof(MyStruct) << std::endl; 	
	return 0;
}
```

为了保证这个结构体中的每个成员都应该出现在它对齐了内存位置上，而在某些位置上插入了一些 Padding。对于结构体类型来说，最理想的内存对齐数值应该是结构体中内存对齐数值最大的成员的内存对齐数。

# 堆内存的内存对齐

使用 malloc 分配内存时，通常并不会考虑内存对齐，实际上 malloc 一般使用当前平台默认的最大内存对齐数对齐内存，比如  MSVC 在 32 位下一般是 8 字节对齐，64 位下是 16 字节对齐。

这种方式对于常规数据是没有问题的，但是如果自定义的内存对齐超过了这个范围，则不能使用 malloc 直接来分配内存。在 MSVC 下应当使用 `_aligned_malloc_` 在 gcc 下一般使用 `memalign` 等函数。

实现一个简易 aligned_malloc：

```
#include <cassert>
inline void* aligned_malloc(size_t size, size_t alignment)
{	
	//@ 检查 alignment 是否是 2 的 N 次幂
	assert(!(alignment & (alignment - 1)));
	//@ 计算出一个最大的 offset，sizeof(void*) 是为了存储原始指针地址
	size_t offset = sizeof(void*) + (--alignment);

	//@ 分配一块带 offset 的内存
	char* p = static_cast<char*>(malloc(offset + size));
	if (!p)
		return nullptr;
	
	//@ 通过 &(~alignment) 把多计算的 offset 减掉
	void* r = reinterpret_cast<void*> (reinterpret_cast<size_t>(p + offset) & (~alignment));

	//@ 将 r 当作一个指向 void* 的指针，在 r 的前地址前面放入原始地址
	static_cast<void**>(r)[-1] = p;

	//@ 返回经过内存对齐的内存地址
	return r;
}

inline void alignment_free(void* p)
{
	free(static_cast<void**>(p)[-1]);
}
```











