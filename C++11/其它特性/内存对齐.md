# 内存对齐介绍

内存对齐是一个数据类型所能存放的内存地址的属性，这个属性是无符号整数，并且这个整数必须是 2 的 N 次方，当说一个数据类型的内存对齐为 8 时，就是指这个数据类型所定义出来的所有变量的内存地址都是 8 的倍数。

当一个基本数据类型的对齐属性和这个数据类型的大小相等时，这种对齐方式称为自然对齐，比如一个 4 字节大小的 int 型数据，在默认情况下它的字节对齐方式是 4。

为什么需要内存对齐？

- 不是每一个硬件平台都能随意访问任意的内存，一些硬件平台读取的数据如果是未对齐的将会拒绝访问或者抛出硬件异常。
- 考虑到 CPU 处理内存的方式，内存对齐将会提高数据的读取效率。

因为内存对齐，所以数据在内存中的存放不是紧挨着的，而是会出现一些空隙(空白填充)，这对基本数据类型来说还能接受，但是对于结构体或类而言，sizeof 的结果往往和想象中不一样：

```
struct MyStruct
{
	char  c1;	//@ 1 bytes
	int   i;	//@ 4 bytes
	short s;	//@ 2 bytes
	long  long  ll; //@ 8 bytes
	char  c2; //@ 1 bytes
}; //@ total 16 bytes

int main()
{
	//@ MSVC 编译器 32 bytes，不同的平台对齐方式可能不一样  
	std::cout << sizeof(MyStruct) << std::endl; 	
	return 0;
}
```

为了保证这个结构体中的每个成员都应该出现在它对齐了内存位置上，而在某些位置上插入了一些 Padding。对于结构体类型来说，最理想的内存对齐数值应该是结构体中内存对齐数值最大的成员的内存对齐数。













