type_traits 提供了编译器计算，查询，判断，转换和选择的帮助类。在一定程序上可以消除冗长的 switch-case 或者 if-else 的语句。type_traits  的类型判断在编译器就可以检查出是否是正确的类型，以便编写更安全的代码。

# 基本的 type_traits 

## 简单的 type_traits 

C++11 之前在类中定义编译器常量的方法：

```
template <typename T>
struct GetLeftSize
{
	static const int value = 1;
};
```

获取常量的方法：

```
GetLeftSize::value
```

还可以通过 enum 来定义编译期常量：

```
template <typename T>
struct GetLeftSize
{
	enum {value = 1;}
};
```

在 C++ 11中定义编译期常量，无须自己定义 static const 或者 enum  类型，只需要从 std::integral_constant 派生：

```
template <typename T>
struct GetLeftSize : std::integral_constant<int, 1>
{
};

int main()
{
	auto res = GetLeftSize<int>::value;  //@ res = 1
	return 0;
}
```

integral_constant 的实现比较简单：

```
template <typename T,T v>
struct integral_constant
{
	static const T value = v;
	typedef T value_type;
	typedef integral_constant<T, v> type;
	operator value_type() { return value; }
};
```

编译期 true 和 false 类型 true_type 和 false_type：

```
typedef std::integral_constant<bool, true> true_type;
typedef std::integral_constant<bool, false> false_type;
```

## 类型判断的 type_traits

这些 type_traits 从 std::integral_constant 派生，用来检查模板类型是否为某种类型，通过这些 traits 可以获取编译期检查的 bool 值结果：

```
template <typename T>
struct is_integral; //@ 用于检查 T 是何种整型类型
```
这种类型判断有：

| traits 类型                                         |                             说明                             |
| :-------------------------------------------------- | :----------------------------------------------------------: |
| template <typename T><br/>struct is_void;           |                      T 是否为 void 类型                      |
| template <typename T><br/>struct is_floating_point; |                       T 是否为浮点类型                       |
| template <typename T><br/>struct is_array;          |                       T 是否为数组类型                       |
| template <typename T><br/>struct is_pointer;        |   T 是否为指针类型(包括函数指针，但不包括成员(函数)指针）    |
| template <typename T><br/>struct is_enum;           |                       T 是否为枚举类型                       |
| template <typename T><br/>struct is_union;          |               T 是否为 union 类型而不是类类型                |
| template <typename T><br/>struct is_class;          |               T 是否为类类型而不是 union 类型                |
| template <typename T><br/>struct is_function;       |                       T 是否为函数类型                       |
| template <typename T><br/>struct is_reference;      |            T 是否为引用类型(左值引用或者右值引用)            |
| template <typename T><br/>struct is_airthmetic;     |                    T 是否为整型或浮点类型                    |
| template <typename T><br/>struct is_fundamental;    |   T 是否为整型、浮点类型、void 类型或 std::nullptr_t 类型    |
| template <typename T><br/>struct is_object;         |       T 是否为对象类型，不是函数，不是引用，不是 void        |
| template <typename T><br/>struct is_scalar;         | T 是否为 airthmetic、enumeration、pointer、pointer to member 或 std::nullptr_t 类型 |
| template <typename T><br/>struct is_compound;       |              T 是否为非 fundamental 类型构造的               |
| template <typename T><br/>struct is_member_pointer; |                   T 是否为成员函数指针类型                   |
| template <typename T><br/>struct is_polymorphic;    |                        T 是否为虚函数                        |
| template <typename T><br/>struct is_abstruct;       |                        T 是否为抽象类                        |
| template <typename T><br/>struct is_signed;         |                      T 是否为有符号类型                      |
| template <typename T><br/>struct is_unsigned;       |                      T 是否为无符号类型                      |
| template <typename T><br/>struct is_const;          |                  T 是否为 const 修饰的类型                   |










