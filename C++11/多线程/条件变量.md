条件变量能阻塞一个或多个线程，直到收到另外一个线程发出的通知或者超时，才会唤醒当前阻塞的线程。

条件变量需要和互斥量配合使用，C++ 11 提供两种条件变量：

- condition_variable，配合 `std::unique_lock<std::mutex`> 进行 wait 操作。
- condition_variable_any，和任意带有 lock，unlock 语义的 mutex 搭配使用，比较灵活，但是效率相对较差。

条件变量的使用过程如下：

- 拥有条件变量的线程获取互斥量。
- 循环检查某个条件，如果条件不满足，则阻塞直到条件满足；如果条件满足，则向下执行。
- 某个线程满足条件执行完之后，再调用 notify_one 或 notify_all 唤醒一个或者所有等待的线程。

利用条件变量实现同步队列：

```
template <typename T>
class SyncQueue
{
	bool IsFull() const
	{
		return queue_.size() == maxSize_;
	}

	bool IsEmpty() const
	{
		return queue_.empty();
	}

public:
	SyncQueue(int max_size) :maxSize_(max_size) {}

	void Put(const T& x)
	{
		std::lock_guard<std::mutex> locker(mutex_);
		while (IsFull())
		{
			std::cout << "queue is full" << std::endl;
			notFull_.wait(mutex_);
		}		

		queue_.push_back(x);
		notEmpty_.notify_one();
	}

	void Take(T& x)
	{
		std::lock_guard<std::mutex> locker(mutex_);
		while (IsEmpty())
		{
			std::cout << "queue is empty" << std::endl;
			notEmpty_.wait(mutex_);
		}

		x = queue_.front();
		queue_.pop_front();
		notEmpty_.notify_one();
	}

	bool Empty()
	{
		std::lock_guard<std::mutex> locker(mutex_);
		return queue_.empty();
	}

	bool Full()
	{
		std::lock_guard<std::mutex> locker(mutex_);
		return queue_.size() == maxSize_;
	}

	size_t Size()
	{
		std::lock_guard<std::mutex> locker(mutex_);
		return queue_.size();
	}

private:
	std::list<T> queue_;  //@ 缓冲区
	std::mutex mutex_;	  //@ 互斥量，和条件变量结合使用
	std::condition_variable_any notEmpty_;  //@ 不为空的条件变量
	std::condition_variable_any notFull_;  //@ 不满的条件变量
	int maxSize_; //@ 同步队列的最大 size
};
```

条件变量的 wait 还有一个重载方法，可以接受一个条件：

```
std::lock_guard<std::mutex> locker(mutex_);
while (IsFull())
{
	notFull_.wait(mutex_);
}		
```

可以修改为：

```
std::lock_guard<std::mutex> locker(mutex_);
notFull_.wait(locker,[this]{return !IsFull();});
```

条件变量会先检查判断式是否满足条件，如果满足条件，则重新获取 mutex，然后结束  wait，继续向下执行。

如果不满足判断式，则释放 mutex，然后将线程置为 waiting 状态，继续等待。









