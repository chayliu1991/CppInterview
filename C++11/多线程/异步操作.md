C++ 11 提供的异步操作相关类：std::future，std::promise，std::package_task：

- std::future 作为异步结果的传输通道，可以很方便地获取线程函数的返回值。
- std::promise 用来包装一个值，将数据和 std::future 绑定起来，方便线程赋值。
- std::package_task 用来包装一个可调用对象，将函数和 std::future 绑定起来，方便异步调用。

# std::future 获取线程函数的返回值

C++ 11 线程库提供了 std::future 来访问异步操作的结果，因为一个异步操作的结果不会马上获取，只能在未来的某个地方获取到，这个异步操作的结果是一个未来的值，因此称为 std::future，std::future 有如下三种状态：

- Deferred，异步操作还没有开始。
- Ready，异步操作已经完成。
- Timeout，异步操作超时。

可以通过查询 std::future 的状态来获取异步操作的结果：

```
std::future_status status;
do
{
    status = future.wait_for(std::chrono::seconds(1));
    if (status == std::future_status::deferred)
    	std::cout << "deferred" << std::endl;
    else if(status == std::future_status::timeout)
    	std::cout << "timeout" << std::endl;
    else if (status == std::future_status::ready)
    	std::cout << "ready" << std::endl;
} while (status != std::future_status::ready);
```

获取结果的方式有三种：

- get，等待异步操作结束并返回结果。
- wait，只等待异步操作完成，没有返回值。
- wait_for，超时等待返回异步操作的状态。

# std::promise 协助线程赋值的类

std::promise  将数据与  std::future 绑定，为获取线程函数中的某个值提供便利，在线程函数中为传进来的 std::promise 赋值，在线程函数执行完毕之后就可以通过 std::promise 的 std::future  获取该值。

需要注意的是，取值是间接地通过  std::promise 内部提供的 std::future 来获取的。

```
std::promise<int> pr;
std::thread t([](std::promise<int>& p) {p.set_value_at_thread_exit(9);},std::ref(pr));
std::future<int> f = pr.get_future();
auto r = f.get();
```

# std::packaged_task 可调用对象的包装类

std::package_task 可以将函数，lambda 表达式，bind 表达式，函数对象等与 std::future 绑定起来，以便异步调用。

```
std::packaged_task<int()> task([] {return 1; });
std::thread t(std::ref(task));
std::future<int> f = task.get_future();
auto r = f.get();
```

# std::future、std::packaged_task 和 std::promise 之间的关系









