# 慎重选择容器类型

## 连续内存容器和基于节点的容器

STL 容器的一种分类方法：连续内存容器和基于节点的容器：

标准的连续内存容器有 vector、string、deque。连续内存容器(或称为基于数组的容器)把它的元素存放在一块或多块(动态分配的)内存中，每块内存中存有多个元素。当有新元素插入或已有的元素被删除时，同一内存块中的其它元素要向前或向后移动，以便为新元素让出空间，或者填充被删除元素所留下的空隙，这种移动影响到效率和异常安全性。

基于节点的容器在每一个(动态分配的)内存块中只存放一个元素。容器中元素的插入或删除只影响到指向节点的指针，而不影响节点本身的内容，所以当有插入或删除操作时，元素的值不需要移动。表示链表的容器，比如 list、forward_list 是基于节点的；所有的标准关联容器也是如此(通常的实现方式是平衡树)。标准的哈希容器使用不同的基于节点的实现。

## 选择容器时最重要的一些问题

- 是否需要在容器的任意位置插入新元素？如果需要，就选择序列容器；关联容器是不行的。
- 是否关心容器中的元素是如何排序的？如果不关心，则哈希容器是一个可行的选择方案；否则，你要避免哈希容器。
- 你需要哪种类型的迭代器？如果它们必须是随机访问迭代器，则对容器的选择就被限定为 vector、deque 和 string。
- 当发生元素的插入或删除操作时，避免移动容器中原来的元素是否很重要？如果是，就要避免连续内存的容器。
- 容器中数据的布局是否需要和 C 兼容？如果需要兼容，就只能选择  vector。
- 元素的查找速度是否是关键的考虑因素？如果是，就要考虑哈希容器、排序的 vector 和标准关联容器。
- 如果容器内部使用了引用计数技术，你是否介意？如果是，就要避免使用 string，因为许多 string 的实现都使用了引用计数。当然，你需要某种表示字符串的方法，这时你可以考虑 vector<char>。
- 对插入和删除操作，你需要事务语义吗？也就是说，在插入和删除操作失败时，你需要回滚的能力吗？如果需要，你就要使用基于节点的容器。如果对多个元素的插入操作(即针对一个区间的形式)需要事务语义，则你需要选择 list，因为在标准容器中，只有 list 对多个元素的插入操作提供了事务语义。对那些希望编写异常安全代码的程序员，事务语义显得尤为重要。(使用连续内存的容器也可以获得事务语义，但是要付出性能上的代价，而且代码也显得不那么直截了当。)
- 你需要使迭代器、指针和引用变为无效的次数最少吗？如果是这样，就要使用基于节点的容器，因为对这类容器的插入和删除操作从来不会使迭代器、指针和引用变得无效(除非它们指向了一个你正在删除的元素)。而针对连续内存容器的插入和删除操作一般会使指向该容器的迭代器、指针和引用变得无效。
- 如果序列容器的迭代器是随机访问类型，而且只要没有删除操作发生，且插入操作只发生在容器的末尾，则指向数据的指针和引用就不会变为无效，这样的容器是否对你有帮助？这是非常特殊的情形，但如果你面对的情形正是如此，则 deque 是你所希望的容器。(当插入操作仅在容器末尾发生时，deque 的迭代器有可能会变为无效。deque 是唯一的、迭代器可能会变为无效而指针和引用不会变为无效的 STL 标准容器。)

# 不要试图编写独立于容器类型的代码

STL 是以泛化原则为基础的：

- 数组被泛化为以其所包含对象的类型为参数的容器。
- 函数被泛化为以其使用的迭代器的类型为参数的算法。
- 指针被泛化为以其所指向的对象的类型为参数的迭代器。
- 容器类型被泛化为序列和关联容器，类似的容器被赋予相似的功能：
  - 标准的连续内存容器提供了随机访问迭代器，而标准的基于节点的容器提供了双向迭代器。
  - 序列容器支持 push_front 和 push _back 操作，而关联容器则不然。
  - 关联容器提供了对数时间的 lower_bound、upper_bound 和 equal_range 成员函数，但序列容器却没有提供。

考虑到以后可能会使用其他的容器替换现有的容器，为了使修改的部分最小化，最好使用 Class 将自定义的容器封装起来，可以更好的实现修改部分最小化，同时达到了安全修改的目的：

```
{
private:   
    typedef vector<Widget> InternalContainer;
    typedef InternalContainer::Iterator ICIterator;
    InternalContainer container;  
public:
	...
};
```

# 确保容器中的对象拷贝正确而高效

拷贝对象是 STL 的工作方式：

- 当通过如  insert 或 push_back 之类的操作向容器中加入对象时，存入容器的是你所指定的对象的拷贝。
- 当通过如 front 或 back 之类的操作从容器中取出一个对象时，你所得到的是容器中所保存的对象的拷贝。
- 当对 vector、string 或 deque 进行元素的插入或删除操作时，现有元素的位置通常会被移动(拷贝)。一些算法施用于容器时也会发生拷贝，例如：unique、rotate、reverse等。

在存在继承关系的情况下，拷贝动作会导致剥离(slicing)。也就是说，如果你创建了一个存放基类对象的容器，却向其中插入派生类的对象，那么在派生类对象(通过基类的拷贝构造函数)被拷贝进容器时，它所特有的部分(即派生类中的信息)将会丢失。”剥离”问题意味着向基类对象的容器中插入派生类对象几乎总是错误的。

```
vector<Widget> vw;

class SpecialWidget : public Widget
{
	...
};

SpecialWidget sw;
vw.push_back(sw);
```

使拷贝动作高效、正确，并防止剥离问题发生的一个简单办法是使容器包含指针而不是对象。

```
vector<Widget*> vw;

class SpecialWidget : public Widget
{
	...
};

SpecialWidget sw;
vw.push_back(&sw);
```

容器与数组在数据拷贝方面的对比：

```
Widget w[maxNumWidgclass Widget
{
public:
	Widget() { std::cout << "ctor" << std::endl; }
	Widget(const Widget& w) { std::cout << "copy ctor" << std::endl; }
};

int main()
{
	Widget arr[5];  //@ 5 次构造函数
	std::vector<Widget> vec(5);  //@ 5 次构造函数
	std::vector<Widget> vec2; //@ 不调用构造函数
	vec2.reserve(5);//@ 不调用构造函数
	vec2.resize(5); //@ 5 次构造函数
	return 0;
}
ets]; //@ maxNumWidgets 次的Widget构造函数
```

# 调用 empty() 而不是检查 size() 是否为0

empty() 对于所有标准容器都是常数时间，而对 list 操作，size() 耗费线性时间。
list 具有常数时间的 Splice 操作，如果在两个 list 之间做链接的时候需要记录被链接到当前 list 的节点的个数，那么 Splice 操作将会变成线性时间。对于 list 而言，用户对 Splice 效率的要求高于取得 list 长度的要求，所以 list 的 size() 需要耗费线性的时间去遍历整个 list。所以，调用 empty() 是判断 list 是否为空的最高效方法。

# 区间成员函数优先于与之对应的单元素成员函数

区间成员函数是指这样的一类成员函数，它们像 STL 算法一样，使用两个迭代器参数来确定该成员操作所执行的区间。如果不使用区间成员函数就得写一个显式的循环。

优先选择区间成员函数而不是其对应的单元素成员函数有三条充分的理由：

- 区间成员函数写起来更容易
- 更能清楚地表达你的意图
- 它们表现出了更高的效率

区间成员函数在效率方面的开销要小于循环调用单元素的成员函数，以 insert 为例：

- 避免不必要的函数调用
- 避免频繁的元素移动
- 避免多次进行内存分配

```
struct Timer
{
	Timer() : start_(std::chrono::high_resolution_clock::now()) {}
	void Reset() { start_ = std::chrono::high_resolution_clock::now(); }
	double ElapsedUs() {
		return std::chrono::duration_cast<microseconds>(std::chrono::high_resolution_clock::now() - start_).count();
	}

	std::chrono::high_resolution_clock::time_point start_;
};

int main()
{
	std::uniform_real_distribution<double> dis;
	std::default_random_engine engi;

	int counts = 5000;
	std::vector<double> vOri(counts);
	for (int i = 0; i < counts; i++)
	{
		vOri[i] = dis(engi);
	}

	Timer t;
	std::vector<double> vTest;
	vTest.assign(vOri.begin() + vOri.size() / 2, vOri.end());
	std::cout << counts << " element assign cost: " << t.ElapsedUs() << " us." << std::endl;
	
	vTest.clear();
	t.Reset();	
	for (std::vector<double>::const_iterator ci = vOri.begin() + vOri.size() / 2; ci != vOri.end(); ++ci)
		vTest.push_back(*ci);
	std::cout << counts << " element push_back cost: " << t.ElapsedUs() << " us." << std::endl;

	vTest.clear();
	t.Reset();	
	std::copy(vOri.begin() + vOri.size() / 2, vOri.end(), std::back_inserter(vTest));
	std::cout << counts << " element copy cost: " << t.ElapsedUs() << " us." << std::endl;

	vTest.clear();
	t.Reset();	
	vTest.insert(vTest.end(), vOri.begin() + vOri.size() / 2, vOri.end());
	std::cout << counts << " element insert cost: " << t.ElapsedUs() << " us." << std::endl;

	return 0;
}
```

结果：

```
5000 element assign cost: 13 us.
5000 element push_back cost: 2132 us.
5000 element copy cost: 1335 us.
5000 element insert cost: 8 us.
```





















  